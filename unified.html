<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Maze Game</title>
    <style>
        body {
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: #f0f0f0;
        }
        canvas {
            display: block;
            background-color: white;
            border: 1px solid #ccc;
            outline: none; /* allow focus without outline */
        }
        .game-container {
            position: relative;
        }
        .info {
            position: absolute;
            top: 10px;
            left: 10px;
            font-family: Arial, sans-serif;
            color: #333;
        }
        /* Add focus indicator styling */
        .focus-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0,0,0,0.7);
            color: white;
            padding: 20px;
            border-radius: 10px;
            font-family: Arial, sans-serif;
            text-align: center;
            pointer-events: none; /* Allow clicks to pass through */
            opacity: 0.8;
            transition: opacity 0.5s;
        }
        canvas:focus + .focus-message {
            opacity: 0;
        }
        /* When canvas has focus, add a subtle highlight */
        canvas:focus {
            box-shadow: 0 0 15px 5px rgba(0, 100, 255, 0.5);
        }
        /* Game over banner styling */
        .game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0,0,0,0.8);
            color: white;
            padding: 30px 50px;
            border-radius: 10px;
            font-family: Arial, sans-serif;
            text-align: center;
            z-index: 10;
            border: 3px solid #ff3333;
            display: none;
        }
        .game-over h2 {
            font-size: 32px;
            margin: 0 0 20px 0;
            color: #ff3333;
        }
        .game-over p {
            font-size: 18px;
            margin: 10px 0;
        }
        .game-over button {
            background-color: #ff3333;
            color: white;
            border: none;
            padding: 10px 20px;
            margin-top: 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
        }
        .game-over button:hover {
            background-color: #cc0000;
        }
        /* Game won banner styling */
        .game-won {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0,0,0,0.8);
            color: white;
            padding: 30px 50px;
            border-radius: 10px;
            font-family: Arial, sans-serif;
            text-align: center;
            z-index: 10;
            border: 3px solid #33cc33;
            display: none;
        }
        .game-won h2 {
            font-size: 32px;
            margin: 0 0 20px 0;
            color: #33cc33;
        }
        .game-won p {
            font-size: 18px;
            margin: 10px 0;
        }
        .game-won button {
            background-color: #33cc33;
            color: white;
            border: none;
            padding: 10px 20px;
            margin-top: 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
        }
        .game-won button:hover {
            background-color: #29a329;
        }
        
        /* Timer styling */
        .timer {
            position: absolute;
            top: 10px;
            right: 10px;
            font-family: Arial, sans-serif;
            color: #333;
            background: rgba(255,255,255,0.7);
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 16px;
        }
    </style>
</head>
<body>
  <div class="game-container">
    <canvas id="gameCanvas" tabindex="1"></canvas>
    <div class="focus-message" id="focusMessage">Click here to play<br>(WASD or Arrows to move, < and > to strafe, Space to shoot)</div>
    <div class="game-over" id="gameOverBanner">
        <h2>GAME OVER</h2>
        <p>You were overrun by spiders!</p>
        <p>Time: <span id="timePlayedLoss">0:00</span></p>
        <button onclick="restartGame()">Play Again</button>
    </div>
    <div class="game-won" id="gameWonBanner">
        <h2>VICTORY!</h2>
        <p>You destroyed all spider nests!</p>
        <p>Time: <span id="timePlayedWin">0:00</span></p>
        <button onclick="restartGame()">Play Again</button>
    </div>
    <div class="timer" id="gameTimer">Time: 0:00</div>
    <div class="info">
      Arrows: <span id="arrowCount">3</span><br>
      Lives: <span id="livesCount">3</span><br>
      Spiders: <span id="spiderCount">0</span><br>
      Nests: <span id="nestCount">3</span>
    </div>
  </div>
  <script>
    // Setup canvas
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    const arrowCountDisplay = document.getElementById("arrowCount");
    const livesCountDisplay = document.getElementById("livesCount");
    
    // Add canvas focus handling to capture keyboard events
    canvas.tabIndex = 1;
    
    // Game settings
    const MAZE_COLS = 8;  // Columns in the maze
    const MAZE_ROWS = 8;  // Rows in the maze
    const ROOM_SIZES = [
        { width: 100, height: 100 }, // Small
        { width: 150, height: 150 }, // Medium
        { width: 200, height: 200 }  // Large
    ];
    const MAX_ARROWS = 3; // Changed from 2 to 3
    const ARROW_SPEED = 4;
    const PLAYER_SPEED = 2;
    const WALL_THICKNESS = 1;
    const SPIDER_SIGHT_RANGE = 4 * ROOM_SIZES[0].width; // Spiders see this far
    
    // Game state
    let arrowCount = MAX_ARROWS;
    let arrows = [];
    let walls = [];
    let camera = { x: 0, y: 0 };
    let movingForward = false;
    let movingBackward = false;
    let rotatingLeft = false;
    let rotatingRight = false;
    let strafingLeft = false;   // New state for strafing movement
    let strafingRight = false;  // New state for strafing movement
    let characterLives = 3;
    let gameOver = false;
    let gameWon = false;        // New flag for win condition
    let gameStartTime = 0;      // When the game started
    let gameTimerStarted = false; // Flag to track if timer has started
    let gameEndTime = 0;        // When game ended
    let elapsedTime = 0;        // Current elapsed time
    
    // Spider AI constants - add death animation properties
    const SPIDER_STATES = {
        PATROL: 'patrol',
        ATTACK: 'attack',
        RETREAT: 'retreat',
        HEAL: 'heal',
        DYING: 'dying'  // New state for death animation
    };
    const SPIDER_PATROL_RANGE = 150; // Maximum patrol distance from nest
    const SPIDER_DETECTION_RANGE = 250; // Distance at which spiders can detect player
    const SPIDER_CHASE_RANGE = 350; // Distance at which spiders will stop chasing
    const SPIDER_MAX_HEALTH = 3; // Maximum spider health
    const SPIDER_HEAL_TIME = 3000; // Time to heal in milliseconds
    const SPIDER_DEATH_ANIMATION_TIME = 1000; // Time for death animation in milliseconds

    // Initialize canvas size
    function resizeCanvas() {
        canvas.width = window.innerWidth * 0.8;
        canvas.height = window.innerHeight * 0.8;
    }
    
    // Player object
    let player = {
        x: 150,
        y: 150,
        angle: 0, // In radians
        speed: 0,
        maxSpeed: PLAYER_SPEED,
        radius: 10,
        rotationSpeed: Math.PI / 60 // Rotation per frame
    };
    
    // Add function to spawn player at a random non-colliding location
    function spawnPlayer() {
        const mazeWidth = MAZE_COLS * ROOM_SIZES[2].width;
        const mazeHeight = MAZE_ROWS * ROOM_SIZES[2].height;
        let attempts = 0;
        do {
            player.x = player.radius + Math.random() * (mazeWidth - 2 * player.radius);
            player.y = player.radius + Math.random() * (mazeHeight - 2 * player.radius);
            attempts++;
        } while (checkCollision(player.x, player.y) && attempts < 100);
    }

    // Initialize the game
    function init() {
        resizeCanvas();
        generateMaze();
        spawnPlayer();
        
        // Reset game timer state
        gameStartTime = 0;
        gameTimerStarted = false;
        gameWon = false;
        gameOver = false;
        
        // Create exactly 3 nests
        nests = [];
        while (nests.length < 3) {
            spawnNest();
        }
        
        // Setup keyboard control handling
        setupControls();
        
        // Start the game loop
        gameLoop();

        // Debug output to help troubleshoot
        console.log("Maze size:", MAZE_COLS * ROOM_SIZES[2].width, "x", MAZE_ROWS * ROOM_SIZES[2].height);
        console.log("Player position:", player.x, player.y);
        console.log("Camera position:", camera.x, camera.y);
        console.log("Canvas size:", canvas.width, canvas.height);

        // Ensure focus works
        canvas.focus();
        console.log("Game initialized, canvas focused:", document.activeElement === canvas);
        
        // Add a click event listener directly to the game container
        document.querySelector('.game-container').addEventListener('click', function() {
            canvas.focus();
            console.log("Game container clicked, canvas focused:", document.activeElement === canvas);
        });

        // Update nest count on start
        document.getElementById("nestCount").textContent = nests.length;

        // Update focus message to include new controls
        document.getElementById("focusMessage").innerHTML = 
            "Click here to play<br>(WASD or Arrows to move/rotate, A/D to strafe, Space to shoot)";
        
        // Hide timer initially - will show on first movement
        document.getElementById("gameTimer").style.display = "none";
    }
    
    // Generate maze with rooms and walls
    function generateMaze() {
        walls = [];
        
        // First, create the outer boundary
        const mazeWidth = MAZE_COLS * ROOM_SIZES[2].width;
        const mazeHeight = MAZE_ROWS * ROOM_SIZES[2].height;
        const outerWallThickness = 4; // thicker outer walls
        
        // Outer walls (top, right, bottom, left)
        walls.push({x: 0, y: 0, width: mazeWidth, height: outerWallThickness});
        walls.push({x: mazeWidth - outerWallThickness, y: 0, width: outerWallThickness, height: mazeHeight});
        walls.push({x: 0, y: mazeHeight - outerWallThickness, width: mazeWidth, height: outerWallThickness});
        walls.push({x: 0, y: 0, width: outerWallThickness, height: mazeHeight});
        
        // Create random rooms within the maze
        let currentX = 0;
        let currentY = 0;
        
        for (let row = 0; row < MAZE_ROWS; row++) {
            currentX = 0;
            for (let col = 0; col < MAZE_COLS; col++) {
                // Choose a random room size
                const sizeIndex = Math.floor(Math.random() * ROOM_SIZES.length);
                const roomSize = ROOM_SIZES[sizeIndex];
                
                // Create room walls with gaps
                createRoomWalls(currentX, currentY, roomSize.width, roomSize.height);
                
                currentX += roomSize.width;
            }
            
            // Force some walls on the right side to make it less empty
            if (Math.random() > 0.3) { // 70% chance for an extra wall
                const wallHeight = ROOM_SIZES[2].height * 0.6;
                const wallY = currentY + (ROOM_SIZES[2].height - wallHeight) * Math.random();
                walls.push({
                    x: mazeWidth - ROOM_SIZES[0].width * (0.5 + Math.random()),
                    y: wallY,
                    width: WALL_THICKNESS * 2,
                    height: wallHeight
                });
            }
            
            currentY += ROOM_SIZES[2].height; // Use large room height for consistent rows
        }
    }
    
    // Create walls for a single room with random gaps
    function createRoomWalls(x, y, width, height) {
        const gapSize = 30; // Size of gaps in walls
        const wallSegments = 3; // Number of potential wall segments per side
        
        // Top wall
        createWallWithGaps(x, y, width, WALL_THICKNESS, wallSegments, true);
        
        // Right wall
        createWallWithGaps(x + width, y, WALL_THICKNESS, height, wallSegments, false);
        
        // Bottom wall
        createWallWithGaps(x, y + height, width, WALL_THICKNESS, wallSegments, true);
        
        // Left wall
        createWallWithGaps(x, y, WALL_THICKNESS, height, wallSegments, false);
    }
    
    // Create a wall with random gaps - increased minimum gap size
    function createWallWithGaps(x, y, width, height, segments, isHorizontal) {
        const gapProbability = 0.4; // Probability of creating a gap in a segment
        const minGapSize = 30; // Minimum gap size for player to pass through (player diameter is 20)
        
        if (isHorizontal) {
            const segmentWidth = width / segments;
            // Ensure segments are wide enough for gaps
            if (segmentWidth < minGapSize * 2) {
                // If segments are too small, create fewer but larger segments
                const adjustedSegments = Math.max(1, Math.floor(width / (minGapSize * 2)));
                const adjustedSegmentWidth = width / adjustedSegments;
                
                for (let i = 0; i < adjustedSegments; i++) {
                    if (Math.random() > gapProbability) {
                        walls.push({
                            x: x + i * adjustedSegmentWidth,
                            y: y,
                            width: adjustedSegmentWidth - minGapSize, // Ensure gap is at least minGapSize
                            height: height
                        });
                    }
                }
            } else {
                // Original logic with guaranteed minimum gap size
                for (let i = 0; i < segments; i++) {
                    if (Math.random() > gapProbability) {
                        walls.push({
                            x: x + i * segmentWidth,
                            y: y,
                            width: segmentWidth - minGapSize, // Ensure gap is at least minGapSize
                            height: height
                        });
                    }
                }
            }
        } else {
            const segmentHeight = height / segments;
            // Ensure segments are tall enough for gaps
            if (segmentHeight < minGapSize * 2) {
                // If segments are too small, create fewer but larger segments
                const adjustedSegments = Math.max(1, Math.floor(height / (minGapSize * 2)));
                const adjustedSegmentHeight = height / adjustedSegments;
                
                for (let i = 0; i < adjustedSegments; i++) {
                    if (Math.random() > gapProbability) {
                        walls.push({
                            x: x,
                            y: y + i * adjustedSegmentHeight,
                            width: width,
                            height: adjustedSegmentHeight - minGapSize // Ensure gap is at least minGapSize
                        });
                    }
                }
            } else {
                // Original logic with guaranteed minimum gap size
                for (let i = 0; i < segments; i++) {
                    if (Math.random() > gapProbability) {
                        walls.push({
                            x: x,
                            y: y + i * segmentHeight,
                            width: width,
                            height: segmentHeight - minGapSize // Ensure gap is at least minGapSize
                        });
                    }
                }
            }
        }
    }
    
    // Update player position with completely reworked strafing logic
    function updatePlayer() {
        if (gameOver || gameWon) return;
        
        // Start timer on first movement
        if (!gameTimerStarted && (movingForward || movingBackward || rotatingLeft || 
            rotatingRight || strafingLeft || strafingRight)) {
            gameStartTime = performance.now();
            gameTimerStarted = true;
            document.getElementById("gameTimer").style.display = "block";
            console.log("Game timer started!");
            
            // Hide focus message if it's still visible
            const focusMessage = document.getElementById("focusMessage");
            if (focusMessage) {
                focusMessage.style.opacity = "0";
            }
        }
        
        // Handle rotation
        if (rotatingLeft) {
            player.angle -= player.rotationSpeed;
        }
        if (rotatingRight) {
            player.angle += player.rotationSpeed;
        }
        
        // Keep angle normalized to avoid floating point errors
        player.angle = ((player.angle % (2 * Math.PI)) + 2 * Math.PI) % (2 * Math.PI);
        
        // Calculate movement directions based on player's facing angle
        const forwardAngle = player.angle;
        const rightAngle = (player.angle + Math.PI/2) % (2 * Math.PI); // 90 degrees clockwise
        
        // Calculate unit vectors for each direction
        const forwardVector = {
            x: Math.cos(forwardAngle),
            y: Math.sin(forwardAngle)
        };
        
        const rightVector = {
            x: Math.cos(rightAngle),
            y: Math.sin(rightAngle)
        };
        
        // Set base speed for different movement types
        const forwardSpeed = player.maxSpeed;
        const backwardSpeed = player.maxSpeed * 0.5;
        const strafeSpeed = player.maxSpeed * 0.8;
        
        // Initialize movement vector
        let movementVector = { x: 0, y: 0 };
        
        // Add forward/backward component
        if (movingForward) {
            movementVector.x += forwardVector.x * forwardSpeed;
            movementVector.y += forwardVector.y * forwardSpeed;
        }
        if (movingBackward) {
            movementVector.x -= forwardVector.x * backwardSpeed;
            movementVector.y -= forwardVector.y * backwardSpeed;
        }
        
        // Add strafe component - always relative to player's current orientation
        if (strafingRight) {
            movementVector.x += rightVector.x * strafeSpeed;
            movementVector.y += rightVector.y * strafeSpeed;
        }
        if (strafingLeft) {
            movementVector.x -= rightVector.x * strafeSpeed;
            movementVector.y -= rightVector.y * strafeSpeed;
        }
        
        // If turning, reduce speed slightly for better control
        if (rotatingLeft || rotatingRight) {
            movementVector.x *= 0.7;
            movementVector.y *= 0.7;
        }
        
        // Calculate the attempted new position
        const attemptedX = player.x + movementVector.x;
        const attemptedY = player.y + movementVector.y;
        
        // Handle collision and movement
        if (!checkCollision(attemptedX, attemptedY)) {
            // No collision: move normally
            player.x = attemptedX;
            player.y = attemptedY;
        } else {
            // Collision detected - try sliding along walls
            
            // Try horizontal movement only
            if (!checkCollision(player.x + movementVector.x, player.y)) {
                player.x += movementVector.x;
            }
            // Try vertical movement only
            else if (!checkCollision(player.x, player.y + movementVector.y)) {
                player.y += movementVector.y;
            }
            // If both fail, player is stuck in a corner - do nothing
        }
        
        updateCamera();
    }
    
    // Check if player would collide with a wall
    function checkCollision(x, y) {
        for (const wall of walls) {
            // Simple circle vs rectangle collision
            const closestX = Math.max(wall.x, Math.min(x, wall.x + wall.width));
            const closestY = Math.max(wall.y, Math.min(y, wall.y + wall.height));
            
            const distanceX = x - closestX;
            const distanceY = y - closestY;
            const distanceSquared = distanceX * distanceX + distanceY * distanceY;
            
            if (distanceSquared < player.radius * player.radius) {
                return true; // Collision detected
            }
        }
        return false;
    }
    
    // Helper function: Get the wall that player is colliding with
    function getCollidingWall(x, y) {
        for (const wall of walls) {
            const closestX = Math.max(wall.x, Math.min(x, wall.x + wall.width));
            const closestY = Math.max(wall.y, Math.min(y, wall.y + wall.height));
            const dx = x - closestX;
            const dy = y - closestY;
            if ((dx * dx + dy * dy) < player.radius * player.radius) {
                return wall;
            }
        }
        return null;
    }

    // Update camera position to follow player with smooth movement
    function updateCamera() {
        // Immediately position camera on player at start
        if (camera.x === 0 && camera.y === 0) {
            camera.x = player.x - canvas.width / 2;
            camera.y = player.y - canvas.height / 2;
        }

        // Calculate the ideal camera position (centered on player)
        const targetCameraX = player.x - canvas.width / 2;
        const targetCameraY = player.y - canvas.height / 2;
        
        // Calculate the buffer zone (50% of viewport)
        const bufferX = canvas.width * 0.25;
        const bufferY = canvas.height * 0.25;
        
        // Only move camera if player is outside the buffer zone
        if (player.x < camera.x + bufferX) {
            camera.x = player.x - bufferX;
        } else if (player.x > camera.x + canvas.width - bufferX) {
            camera.x = player.x - canvas.width + bufferX;
        }
        
        if (player.y < camera.y + bufferY) {
            camera.y = player.y - bufferY;
        } else if (player.y > camera.y + canvas.height - bufferY) {
            camera.y = player.y - canvas.height + bufferY;
        }
        
        // Add smooth camera movement
        camera.x += (targetCameraX - camera.x) * 0.05;
        camera.y += (targetCameraY - camera.y) * 0.05;
        
        // Ensure camera doesn't go out of bounds
        const mazeWidth = MAZE_COLS * ROOM_SIZES[2].width;
        const mazeHeight = MAZE_ROWS * ROOM_SIZES[2].height;
        
        camera.x = Math.max(0, Math.min(camera.x, mazeWidth - canvas.width));
        camera.y = Math.max(0, Math.min(camera.y, mazeHeight - canvas.height));
    }
    
    // Fire an arrow from the player - simplified for reliability
    function fireArrow() {
        if (gameOver) return;
        console.log("Attempting to fire arrow, count:", arrowCount);
        
        if (arrowCount > 0) {
            // Create a new arrow
            const newArrow = {
                x: player.x,
                y: player.y,
                angle: player.angle,
                speed: ARROW_SPEED,
                stuckTime: 0,
                isStuck: false,
                stuckX: 0,
                stuckY: 0
            };
            
            // Add arrow to array
            arrows.push(newArrow);
            
            // Decrease arrow count and update display
            arrowCount--;
            arrowCountDisplay.textContent = arrowCount;
            
            console.log("Arrow fired! Remaining:", arrowCount);
        }
    }
    
    // Update arrows (movement and collision) - shorten range by 20%
    function updateArrows() {
        if (gameOver) return;
        for (let i = arrows.length - 1; i >= 0; i--) {
            const arrow = arrows[i];
            
            if (arrow.isStuck) {
                // If arrow is stuck in a wall, count down its "stuck time"
                arrow.stuckTime++;
                if (arrow.stuckTime > 120) { // 2 seconds at 60fps
                    arrows.splice(i, 1);
                    arrowCount++;
                    arrowCountDisplay.textContent = arrowCount;
                }
                continue;
            }
            
            // Move the arrow
            const newX = arrow.x + Math.cos(arrow.angle) * arrow.speed;
            const newY = arrow.y + Math.sin(arrow.angle) * arrow.speed;
            
            // Check for collision with walls
            let collision = false;
            for (const wall of walls) {
                // Line vs rectangle collision (simplified)
                // Check if the arrow's path intersects with the wall
                const lineStart = { x: arrow.x, y: arrow.y };
                const lineEnd = { x: newX, y: newY };
                
                // Check each edge of the wall
                if (lineIntersectsRect(lineStart, lineEnd, wall)) {
                    arrow.isStuck = true;
                    arrow.stuckTime = 0;
                    // Position the arrow at the wall
                    const intersection = findIntersection(lineStart, lineEnd, wall);
                    arrow.stuckX = intersection.x;
                    arrow.stuckY = intersection.y;
                    collision = true;
                    break;
                }
            }
            
            if (!collision) {
                arrow.x = newX;
                arrow.y = newY;
                
                // Check if arrow has traveled too far (reduced by 20% from 1/3 to ~1/4 of window width)
                const distanceTraveled = Math.sqrt(
                    Math.pow(arrow.x - player.x, 2) + Math.pow(arrow.y - player.y, 2)
                );
                if (distanceTraveled > window.innerWidth / 3 * 0.8) { // 20% shorter range
                    arrows.splice(i, 1);
                    arrowCount++;
                    arrowCountDisplay.textContent = arrowCount;
                }
            }
        }
    }
    
    // Helper function: Find if a line intersects with a rectangle
    function lineIntersectsRect(lineStart, lineEnd, rect) {
        // Check intersection with each edge of the rectangle
        const rectLines = [
            { start: {x: rect.x, y: rect.y}, end: {x: rect.x + rect.width, y: rect.y} },
            { start: {x: rect.x + rect.width, y: rect.y}, end: {x: rect.x + rect.width, y: rect.y + rect.height} },
            { start: {x: rect.x + rect.width, y: rect.y + rect.height}, end: {x: rect.x, y: rect.y + rect.height} },
            { start: {x: rect.x, y: rect.y + rect.height}, end: {x: rect.x, y: rect.y} }
        ];
        
        for (const line of rectLines) {
            if (linesIntersect(lineStart, lineEnd, line.start, line.end)) {
                return true;
            }
        }
        return false;
    }
    
    // Helper function: Find if two lines intersect
    function linesIntersect(a, b, c, d) {
        const denominator = ((b.y - a.y) * (d.x - c.x)) - ((b.x - a.x) * (d.y - c.y));
        
        if (denominator === 0) {
            return false;
        }
        
        const ua = (((b.x - a.x) * (c.y - a.y)) - ((b.y - a.y) * (c.x - a.x))) / denominator;
        const ub = (((d.x - c.x) * (c.y - a.y)) - ((d.y - c.y) * (c.x - a.x))) / denominator;
        
        return (ua >= 0 && ua <= 1) && (ub >= 0 && ub <= 1);
    }
    
    // Helper function: Find the intersection point of a line and a wall
    function findIntersection(lineStart, lineEnd, rect) {
        // This is a simplified version - just returns a point near the wall
        // In a full implementation, you'd calculate the exact intersection point
        return {
            x: lineEnd.x,
            y: lineEnd.y
        };
    }
    
    // New functions for handling nests and spiders
    let nests = [];
    let spiders = [];

    // Update spawnNest to properly avoid wall collisions
    function spawnNest() {
        const mazeWidth = MAZE_COLS * ROOM_SIZES[2].width;
        const mazeHeight = MAZE_ROWS * ROOM_SIZES[2].height;
        let attempts = 0;
        let nestX, nestY;
        const nestRadius = 20; // Size of nest for collision checking
        
        // Keep trying positions until we find one without wall collision
        do {
            nestX = nestRadius + Math.random() * (mazeWidth - 2 * nestRadius);
            nestY = nestRadius + Math.random() * (mazeHeight - 2 * nestRadius);
            attempts++;
            
            // Debug output to track attempts
            if (attempts > 50) {
                console.log("Warning: Many attempts to place nest without wall collision");
            }
        } while (nestCollidesWithWall(nestX, nestY, nestRadius) && attempts < 100);
        
        nests.push({
            x: nestX,
            y: nestY,
            hp: 3,
            lastSpawnTime: performance.now() - 25000 // Initialize 25 seconds ago to spawn first spider soon
        });
        
        console.log("Nest created at position:", nestX, nestY);
        document.getElementById("nestCount").textContent = nests.length;
    }

    // Add helper function to check nest-wall collisions
    function nestCollidesWithWall(x, y, radius) {
        for (const wall of walls) {
            // Circle vs rectangle collision check
            const closestX = Math.max(wall.x, Math.min(x, wall.x + wall.width));
            const closestY = Math.max(wall.y, Math.min(y, wall.y + wall.height));
            
            const distanceX = x - closestX;
            const distanceY = y - closestY;
            const distanceSquared = distanceX * distanceX + distanceY * distanceY;
            
            if (distanceSquared < radius * radius) {
                return true; // Collision detected
            }
        }
        return false;
    }

    // Make spawnSpiders more reliable with better logging and shorter interval
    function spawnSpiders() {
        if (gameOver) return;
        const currentTime = performance.now();
        nests.forEach((nest, index) => {
            // Check if nest has lastSpawnTime property
            if (!nest.lastSpawnTime) {
                nest.lastSpawnTime = currentTime - 25000; // Initialize if missing
                console.log("Fixed missing lastSpawnTime for nest", index);
            }
            
            // Reduced spawn time to 15 seconds for testing (15000ms)
            if (currentTime - nest.lastSpawnTime >= 15000) {
                spiders.push({
                    x: nest.x,
                    y: nest.y,
                    speed: 0.5,
                    angle: Math.random() * 2 * Math.PI,
                    state: SPIDER_STATES.PATROL,
                    nestX: nest.x,     // Remember origin nest position
                    nestY: nest.y,
                    patrolAngle: Math.random() * 2 * Math.PI, // Random patrol direction
                    patrolDistance: 0,  // Current distance from nest
                    lastStateChange: currentTime,
                    lastDirectionChange: currentTime,
                    health: SPIDER_MAX_HEALTH, // Health property
                    healStartTime: 0,   // Track healing start time
                    opacity: 1.0,       // New: for death animation
                    deathStartTime: 0   // New: track when death animation started
                });
                nest.lastSpawnTime = currentTime;
                console.log("Spider spawned from nest", index, "at time:", currentTime);
                document.getElementById("spiderCount").textContent = spiders.length;
            }
        });
    }

    // Enhanced spider update function with improved retreat behavior and death animation
    function updateSpiders() {
        if (gameOver) return;
        const currentTime = performance.now();
        
        // Filter out spiders that have completed death animation
        spiders = spiders.filter(spider => {
            if (spider.state === SPIDER_STATES.DYING) {
                // Check if death animation is complete
                const deathProgress = currentTime - spider.deathStartTime;
                if (deathProgress >= SPIDER_DEATH_ANIMATION_TIME) {
                    console.log("Spider removed after death animation");
                    return false; // Remove from array
                }
            }
            return true; // Keep in array
        });
        
        spiders.forEach((spider, index) => {
            // Handle death animation
            if (spider.state === SPIDER_STATES.DYING) {
                const deathProgress = currentTime - spider.deathStartTime;
                spider.opacity = 1 - (deathProgress / SPIDER_DEATH_ANIMATION_TIME);
                return; // Skip other logic for dying spiders
            }
            
            // Calculate distance to player
            const dx = player.x - spider.x;
            const dy = player.y - spider.y;
            const distanceToPlayer = Math.hypot(dx, dy);
            
            // Calculate distance to nest
            const dxNest = spider.nestX - spider.x;
            const dyNest = spider.nestY - spider.y;
            const distanceToNest = Math.hypot(dxNest, dyNest);
            
            // Line of sight check
            const hasLineOfSight = !walls.some(wall => 
                lineIntersectsRect({x: spider.x, y: spider.y}, {x: player.x, y: player.y}, wall)
            );
            
            // Update spider state based on current state and conditions
            switch(spider.state) {
                case SPIDER_STATES.PATROL:
                    // Check if player is detected
                    if (distanceToPlayer < SPIDER_DETECTION_RANGE && hasLineOfSight) {
                        spider.state = SPIDER_STATES.ATTACK;
                        spider.lastStateChange = currentTime;
                        console.log("Spider switched to attack state");
                    }
                    
                    // Change direction occasionally or if getting too far from nest
                    const shouldChangeDirection = 
                        (currentTime - spider.lastDirectionChange > 3000) || // Every 3 seconds
                        (distanceToNest > SPIDER_PATROL_RANGE);              // Or if too far from nest
                        
                    if (shouldChangeDirection) {
                        if (distanceToNest > SPIDER_PATROL_RANGE * 0.8) {
                            // If near patrol boundary, head back toward nest
                            spider.patrolAngle = Math.atan2(dyNest, dxNest) + 
                                (Math.random() - 0.5) * Math.PI/2; // Add some randomness
                        } else {
                            // Otherwise pick a new random direction
                            spider.patrolAngle = Math.random() * 2 * Math.PI;
                        }
                        spider.lastDirectionChange = currentTime;
                    }
                    
                    // Set movement angle to patrol angle
                    spider.angle = spider.patrolAngle;
                    
                    // Use slower patrol speed
                    spider.speed = 0.375;
                    break;
                    
                case SPIDER_STATES.ATTACK:
                    // Check if player is out of range or no longer visible
                    if (distanceToPlayer > SPIDER_CHASE_RANGE || !hasLineOfSight) {
                        spider.state = SPIDER_STATES.PATROL;
                        spider.lastStateChange = currentTime;
                        console.log("Spider switched to patrol state (lost player)");
                    }
                    
                    // Direct line of sight - move straight toward player
                    if (hasLineOfSight) {
                        spider.angle = Math.atan2(dy, dx);
                    } else {
                        // Use pathfinding to navigate around walls
                        // Try several potential angles
                        const directAngle = Math.atan2(dy, dx);
                        const potentialAngles = [
                            directAngle,
                            directAngle + Math.PI/6,   // +30 degrees
                            directAngle - Math.PI/6,   // -30 degrees
                            directAngle + Math.PI/3,   // +60 degrees
                            directAngle - Math.PI/3,   // -60 degrees
                            directAngle + Math.PI/2,   // +90 degrees
                            directAngle - Math.PI/2    // -90 degrees
                        ];
                        
                        // Find best angle for approaching
                        let bestAngle = spider.angle;
                        let bestScore = -Infinity;
                        
                        potentialAngles.forEach(angle => {
                            // Test position after moving in this direction
                            const testDistance = spider.speed * 5; // Look ahead
                            const testX = spider.x + Math.cos(angle) * testDistance;
                            const testY = spider.y + Math.sin(angle) * testDistance;
                            
                            // Skip angles that would hit a wall
                            if (checkSpiderWallCollision(testX, testY, 7)) {
                                return;
                            }
                            
                            // Calculate new distance to player
                            const newDx = player.x - testX;
                            const newDy = player.y - testY;
                            const newDistance = Math.hypot(newDx, newDy);
                            
                            // Score is how much closer we get to player
                            const score = distanceToPlayer - newDistance;
                            
                            if (score > bestScore) {
                                bestScore = score;
                                bestAngle = angle;
                            }
                        });
                        
                        // Gradually adjust angle toward best direction
                        spider.angle = spider.angle + (bestAngle - spider.angle) * 0.2;
                    }
                    
                    // Use faster chase speed
                    spider.speed = PLAYER_SPEED * 0.9; // 90% of player speed
                    break;
                    
                case SPIDER_STATES.RETREAT:
                    // Check if reached nest center (use smaller threshold for more precise positioning)
                    if (distanceToNest < 10) {
                        spider.state = SPIDER_STATES.HEAL;
                        spider.healStartTime = currentTime;
                        spider.lastStateChange = currentTime;
                        console.log("Spider reached nest and starts healing");
                        
                        // Ensure spider is exactly at nest center for healing
                        spider.x = spider.nestX;
                        spider.y = spider.nestY;
                    }
                    
                    // Set angle toward nest center
                    spider.angle = Math.atan2(dyNest, dxNest);
                    
                    // Check if there are obstacles between spider and nest
                    const pathToNestBlocked = walls.some(wall => 
                        lineIntersectsRect({x: spider.x, y: spider.y}, {x: spider.nestX, y: spider.nestY}, wall)
                    );
                    
                    if (pathToNestBlocked) {
                        // Use advanced pathfinding to navigate around obstacles
                        const retreatAngles = [];
                        
                        // Try many more angles for better coverage
                        for (let i = 0; i < 12; i++) {
                            retreatAngles.push(Math.atan2(dyNest, dxNest) + (i * Math.PI / 6));
                        }
                        
                        // Find the best path that doesn't hit a wall and gets closer to nest
                        let bestRetreatAngle = spider.angle;
                        let bestRetreatScore = -Infinity;
                        
                        retreatAngles.forEach(angle => {
                            // Test position after moving in this direction
                            const testDistance = spider.speed * 10; // Look further ahead when retreating
                            const testX = spider.x + Math.cos(angle) * testDistance;
                            const testY = spider.y + Math.sin(angle) * testDistance;
                            
                            // Skip angles that would hit a wall
                            if (checkSpiderWallCollision(testX, testY, 7)) {
                                return;
                            }
                            
                            // Score - how much closer to nest
                            const newDxNest = spider.nestX - testX;
                            const newDyNest = spider.nestY - testY;
                            const newDistanceToNest = Math.hypot(newDxNest, newDyNest);
                            
                            // Score is how much closer we get to nest, with a bonus for more direct paths
                            const directness = 1 - Math.abs(angle - Math.atan2(dyNest, dxNest)) / Math.PI;
                            const score = (distanceToNest - newDistanceToNest) + (directness * 5);
                            
                            if (score > bestRetreatScore) {
                                bestRetreatScore = score;
                                bestRetreatAngle = angle;
                            }
                        });
                        
                        // Follow the best path, with more decisive movement
                        spider.angle = bestRetreatAngle;
                    }
                    
                    // Move faster when retreating (urgently returning to nest)
                    spider.speed = 0.7;
                    break;
                    
                case SPIDER_STATES.HEAL:
                    // Stay at nest for SPIDER_HEAL_TIME
                    if (currentTime - spider.healStartTime >= SPIDER_HEAL_TIME) {
                        // Restore health and return to patrol
                        spider.health = SPIDER_MAX_HEALTH;
                        spider.state = SPIDER_STATES.PATROL;
                        spider.lastStateChange = currentTime;
                        console.log("Spider fully healed, returning to patrol");
                    }
                    
                    // Stay still while healing
                    spider.speed = 0;
                    break;
            }
            
            // Move spider according to calculated angle and speed (unless healing)
            if (spider.state !== SPIDER_STATES.HEAL) {
                const spiderDx = Math.cos(spider.angle) * spider.speed;
                const spiderDy = Math.sin(spider.angle) * spider.speed;
                const newX = spider.x + spiderDx;
                const newY = spider.y + spiderDy;
                
                // Check for wall collision using specific spider collision check
                if (!checkSpiderWallCollision(newX, newY, 7)) {
                    // No collision, move normally
                    spider.x = newX;
                    spider.y = newY;
                } else {
                    // Try wall avoidance maneuvers
                    trySpiderWallAvoidance(spider, spiderDx, spiderDy);
                }
            }

            // Check collision with player
            if (Math.hypot(player.x - spider.x, player.y - spider.y) < player.radius + 5) {
                characterLives--;
                livesCountDisplay.textContent = characterLives;
                spiders.splice(index, 1);
                if (characterLives <= 0) {
                    gameOver = true;
                    
                    // Record game end time and calculate duration
                    gameEndTime = performance.now();
                    const finalTime = updateTimer();
                    
                    // Update game over banner with time
                    document.getElementById("timePlayedLoss").textContent = finalTime;
                    document.getElementById("gameOverBanner").style.display = "block";
                    
                    console.log("Game Over! Time played:", finalTime);
                }
            }
        });
        
        // Update the spider count display
        document.getElementById("spiderCount").textContent = spiders.length;
    }

    // Helper function: Check if spider would collide with a wall
    function checkSpiderWallCollision(x, y, radius) {
        for (const wall of walls) {
            // Circle vs rectangle collision
            const closestX = Math.max(wall.x, Math.min(x, wall.x + wall.width));
            const closestY = Math.max(wall.y, Math.min(y, wall.y + wall.height));
            
            const distanceX = x - closestX;
            const distanceY = y - closestY;
            const distanceSquared = distanceX * distanceX + distanceY * distanceY;
            
            if (distanceSquared < radius * radius) {
                return true; // Collision detected
            }
        }
        return false;
    }

    // Helper function: Try different movement directions when a spider hits a wall
    function trySpiderWallAvoidance(spider, dx, dy) {
        const moveAngle = spider.angle;
        const speed = spider.speed;
        
        // Try horizontal slide
        if (!checkSpiderWallCollision(spider.x + dx, spider.y, 7)) {
            spider.x += dx;
        }
        // Try vertical slide 
        else if (!checkSpiderWallCollision(spider.x, spider.y + dy, 7)) {
            spider.y += dy;
        }
        // Try different angles
        else {
            // Try 45 degree right
            const angle45Right = moveAngle + Math.PI/4;
            const dx45Right = Math.cos(angle45Right) * speed;
            const dy45Right = Math.sin(angle45Right) * speed;
            
            if (!checkSpiderWallCollision(spider.x + dx45Right, spider.y + dy45Right, 7)) {
                spider.x += dx45Right;
                spider.y += dy45Right;
                // Keep turning away from wall
                spider.patrolAngle = angle45Right;
            }
            // Try 45 degree left
            else {
                const angle45Left = moveAngle - Math.PI/4;
                const dx45Left = Math.cos(angle45Left) * speed;
                const dy45Left = Math.sin(angle45Left) * speed;
                
                if (!checkSpiderWallCollision(spider.x + dx45Left, spider.y + dy45Left, 7)) {
                    spider.x += dx45Left;
                    spider.y += dy45Left;
                    // Keep turning away from wall
                    spider.patrolAngle = angle45Left;
                }
                // If all else fails, reverse direction
                else {
                    spider.patrolAngle = moveAngle + Math.PI;
                }
            }
        }
    }

    // Update checkArrowCollisions to handle spider health and death animation
    function checkArrowCollisions() {
        if (gameOver) return;
        for (let i = arrows.length - 1; i >= 0; i--) {
            const arrow = arrows[i];
            
            // Check arrow collision with spiders
            for (let j = spiders.length - 1; j >= 0; j--) {
                const spider = spiders[j];
                
                // Skip spiders that are already dying
                if (spider.state === SPIDER_STATES.DYING) continue;
                
                // First check if they're close enough
                if (Math.hypot(arrow.x - spider.x, arrow.y - spider.y) < 11) { // Reduced from 15
                    
                    // Then check if there's a wall between them
                    const lineBlocked = walls.some(wall => 
                        lineIntersectsRect(
                            {x: arrow.x, y: arrow.y}, 
                            {x: spider.x, y: spider.y}, 
                            wall
                        )
                    );
                    
                    // Only hit the spider if no walls are in the way
                    if (!lineBlocked) {
                        // Reduce spider health
                        spider.health--;
                        console.log("Spider hit! Health:", spider.health);
                        
                        // Change state to retreat if health is critical
                        if (spider.health === 1) {
                            spider.state = SPIDER_STATES.RETREAT;
                            spider.lastStateChange = performance.now();
                            console.log("Spider retreating to nest!");
                        }
                        
                        // Start death animation if health is depleted
                        if (spider.health <= 0) {
                            spider.state = SPIDER_STATES.DYING;
                            spider.deathStartTime = performance.now();
                            spider.opacity = 1.0; // Start fully visible
                            spider.speed = 0; // Stop moving
                            console.log("Spider dying!");
                        }
                        
                        // Remove arrow in any case
                        arrows.splice(i, 1);
                        arrowCount++;
                        arrowCountDisplay.textContent = arrowCount;
                        break;
                    }
                }
            }
            
            // Check nest collisions (unchanged)
            for (let k = 0; k < nests.length; k++) {
                const nest = nests[k];
                const distance = Math.sqrt(Math.pow(arrow.x - nest.x, 2) + Math.pow(arrow.y - nest.y, 2));
                if (distance < 25) { // Nest radius
                    nest.hp--;
                    arrows.splice(i, 1);
                    arrowCount++;
                    arrowCountDisplay.textContent = arrowCount;
                    if (nest.hp <= 0) {
                        nests.splice(k, 1);
                        console.log("Nest destroyed!");
                        document.getElementById("nestCount").textContent = nests.length;
                        
                        // Check win condition immediately when last nest is destroyed
                        if (nests.length === 0 && spiders.length === 0) {
                            checkWinCondition();
                        }
                    }
                    break;
                }
            }
        }
    }

    // Draw spiders with visual indication of their state
    function drawBaddies() {
        // Draw nests as purple circles
        nests.forEach(nest => {
            ctx.fillStyle = 'purple';
            ctx.beginPath();
            ctx.arc(nest.x, nest.y, 20, 0, 2 * Math.PI);
            ctx.fill();
        });

        // Draw spiders with different colors based on state
        spiders.forEach(spider => {
            ctx.save();
            ctx.translate(spider.x, spider.y);
            
            // Set opacity for death animation
            if (spider.state === SPIDER_STATES.DYING) {
                ctx.globalAlpha = spider.opacity;
            }
            
            // Spider body - 30% smaller (7px radius instead of 10px)
            const spiderRadius = 7;
            ctx.beginPath();
            ctx.arc(0, 0, spiderRadius, 0, 2 * Math.PI);
            
            // Change color based on state
            switch(spider.state) {
                case SPIDER_STATES.PATROL:
                    ctx.strokeStyle = 'orange'; // Orange for patrol
                    break;
                case SPIDER_STATES.ATTACK:
                    ctx.strokeStyle = 'red';    // Red for attack
                    break;
                case SPIDER_STATES.RETREAT:
                    ctx.strokeStyle = 'gray';   // Gray for retreat
                    break;
                case SPIDER_STATES.HEAL:
                    ctx.strokeStyle = 'green';  // Green for healing
                    break;
                case SPIDER_STATES.DYING:
                    ctx.strokeStyle = 'darkred'; // Darker red for dying
                    break;
            }
            
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // Draw health indicators (except for dying spiders)
            if (spider.state !== SPIDER_STATES.DYING) {
                for (let i = 0; i < SPIDER_MAX_HEALTH; i++) {
                    const healthX = (i - 1) * 5 - 2;
                    const healthY = -spiderRadius - 5;
                    ctx.beginPath();
                    ctx.rect(healthX, healthY, 4, 2);
                    
                    // Show filled or empty health bars
                    if (i < spider.health) {
                        ctx.fillStyle = 'red';
                        ctx.fill();
                    } else {
                        ctx.strokeStyle = 'darkred';
                        ctx.stroke();
                    }
                }
            }
            
            // Draw 8 legs around the body - 30% shorter
            const legOuterLength = 11; // Reduced from 16
            for (let i = 0; i < 8; i++) {
                const angle = i * Math.PI / 4;
                ctx.beginPath();
                ctx.moveTo(Math.cos(angle) * spiderRadius, Math.sin(angle) * spiderRadius);
                ctx.lineTo(Math.cos(angle) * legOuterLength, Math.sin(angle) * legOuterLength);
                
                // Legs match body color
                if (spider.state === SPIDER_STATES.DYING) {
                    ctx.strokeStyle = 'darkred';
                } else {
                    ctx.strokeStyle = 
                        spider.state === SPIDER_STATES.PATROL ? 'orange' : 
                        spider.state === SPIDER_STATES.ATTACK ? 'red' :
                        spider.state === SPIDER_STATES.RETREAT ? 'gray' : 'green';
                }
                ctx.lineWidth = 1;
                ctx.stroke();
            }
            
            // Draw direction indicator (except for dying spiders)
            if (spider.state !== SPIDER_STATES.DYING) {
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(Math.cos(spider.angle) * (spiderRadius + 5), 
                          Math.sin(spider.angle) * (spiderRadius + 5));
                ctx.strokeStyle = 'white';
                ctx.stroke();
            }
            
            ctx.restore();
        });
    }

    // Draw the game world
    function render() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.save();
        // Apply camera transformation
        ctx.translate(-camera.x, -camera.y);
        
        // Draw walls
        ctx.fillStyle = 'black';
        for (const wall of walls) {
            // Only draw walls that are potentially visible
            if (wall.x + wall.width >= camera.x && 
                wall.x <= camera.x + canvas.width &&
                wall.y + wall.height >= camera.y && 
                wall.y <= camera.y + canvas.height) {
                ctx.fillRect(wall.x, wall.y, wall.width, wall.height);
            }
        }
        
        // Draw outer boundary
        const mazeWidth = MAZE_COLS * ROOM_SIZES[2].width;
        const mazeHeight = MAZE_ROWS * ROOM_SIZES[2].height;
        ctx.strokeStyle = 'white';
        ctx.lineWidth = 6;
        ctx.strokeRect(0, 0, mazeWidth, mazeHeight);
        
        // Draw arrows
        for (const arrow of arrows) {
            ctx.save();
            if (arrow.isStuck) {
                // Draw stuck arrow
                ctx.translate(arrow.stuckX, arrow.stuckY);
                ctx.rotate(arrow.angle);
                // Arrow body
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(-10, 0);
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 2;
                ctx.stroke();
                // Arrow head
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(-4, 3);
                ctx.lineTo(-4, -3);
                ctx.closePath();
                ctx.fillStyle = 'black';
                ctx.fill();
            } else {
                // Draw moving arrow
                ctx.translate(arrow.x, arrow.y);
                ctx.rotate(arrow.angle);
                // Arrow body
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(-10, 0);
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 2;
                ctx.stroke();
                // Arrow head
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(-4, 3);
                ctx.lineTo(-4, -3);
                ctx.closePath();
                ctx.fillStyle = 'black';
                ctx.fill();
            }
            ctx.restore();
        }
        
        // Draw player
        ctx.save();
        ctx.translate(player.x, player.y);
        ctx.rotate(player.angle);
        // Player circle
        ctx.beginPath();
        ctx.arc(0, 0, player.radius, 0, Math.PI * 2);
        ctx.fillStyle = 'black';
        ctx.fill();
        // Direction indicator (arrow)
        ctx.beginPath();
        ctx.moveTo(player.radius, 0);
        ctx.lineTo(player.radius - 5, -5);
        ctx.lineTo(player.radius - 5, 5);
        ctx.closePath();
        ctx.fillStyle = 'white';
        ctx.fill();
        ctx.restore();
        
        // Draw baddies
        drawBaddies();
        
        // Restore camera transformation
        ctx.restore();
        
        // Update UI elements
        arrowCountDisplay.textContent = arrowCount;
        livesCountDisplay.textContent = characterLives;
        document.getElementById("spiderCount").textContent = spiders.length;
    }

    // Fix setupControls to ensure key presses are correctly processed
    function setupControls() {
        // Clean up any existing handlers
        if (window.handleKeyDown) {
            document.removeEventListener('keydown', window.handleKeyDown);
        }
        if (window.handleKeyUp) {
            document.removeEventListener('keyup', window.handleKeyUp);
        }
        
        // Define new handlers
        window.handleKeyDown = function(e) {
            keyHandler(e, true);
        };
        
        window.handleKeyUp = function(e) {
            keyHandler(e, false);
        };

        // Ensure key presses are processed regardless of focus
        const keyHandler = (e, isKeyDown) => {
            // Check if game is active
            if (gameOver || gameWon) return;
            
            // Hide focus message on any key press
            if (isKeyDown) {
                const focusMessage = document.getElementById("focusMessage");
                if (focusMessage) {
                    focusMessage.style.opacity = "0";
                }
            }
            
            // Process key inputs
            switch(e.key) {
                case 'w':
                case 'ArrowUp':
                    movingForward = isKeyDown;
                    e.preventDefault();
                    break;
                case 's':
                case 'ArrowDown':
                    movingBackward = isKeyDown;
                    e.preventDefault();
                    break;
                case 'a':
                    strafingLeft = isKeyDown;
                    e.preventDefault();
                    break;
                case 'd':
                    strafingRight = isKeyDown;
                    e.preventDefault();
                    break;
                case 'ArrowLeft':
                    rotatingLeft = isKeyDown;
                    e.preventDefault();
                    break;
                case 'ArrowRight':
                    rotatingRight = isKeyDown;
                    e.preventDefault();
                    break;
                case ',':
                case '<':
                    strafingLeft = isKeyDown;
                    e.preventDefault();
                    break;
                case '.':
                case '>':
                    strafingRight = isKeyDown;
                    e.preventDefault();
                    break;
                case ' ':
                case 'f':
                    if (isKeyDown) {
                        fireArrow();
                    }
                    e.preventDefault();
                    break;
            }
        };

        // Add event listeners directly to document
        document.addEventListener('keydown', window.handleKeyDown);
        document.addEventListener('keyup', window.handleKeyUp);
        
        // Handle clicks to hide the focus message
        document.addEventListener('click', function() {
            const focusMessage = document.getElementById("focusMessage");
            if (focusMessage) {
                focusMessage.style.opacity = "0";
            }
            canvas.focus();
        });
        
        // Handle window resize
        window.addEventListener('resize', resizeCanvas);
    }
    
    // Add function to update timer display
    function updateTimer() {
        if (!gameTimerStarted) return "0:00";
        
        const currentTime = performance.now();
        elapsedTime = Math.floor((currentTime - gameStartTime) / 1000); // Time in seconds
        
        // Format time as minutes:seconds
        const minutes = Math.floor(elapsedTime / 60);
        const seconds = elapsedTime % 60;
        const formattedTime = `${minutes}:${seconds.toString().padStart(2, '0')}`;
        
        // Update timer display if game is active
        if (!gameOver && !gameWon) {
            document.getElementById("gameTimer").textContent = `Time: ${formattedTime}`;
        }
        
        return formattedTime;
    }
    
    // Add function to check for win condition
    function checkWinCondition() {
        // Win when all nests are destroyed and no spiders remain
        if (!gameOver && !gameWon && nests.length === 0 && spiders.length === 0) {
            gameWon = true;
            gameEndTime = performance.now();
            
            // Calculate final time
            const finalTime = updateTimer();
            
            // Show win banner with time
            document.getElementById("timePlayedWin").textContent = finalTime;
            document.getElementById("gameWonBanner").style.display = "block";
            
            console.log("Victory! Game completed in", finalTime);
        }
    }
    
    // Modify gameLoop to check for win condition and update timer
    function gameLoop() {
        updatePlayer();
        updateArrows();
        spawnSpiders();
        updateSpiders();
        checkArrowCollisions();
        
        // Check win condition and update timer
        checkWinCondition();
        if (gameTimerStarted) {
            updateTimer();
        }
        
        render();
        
        // Store the animation frame ID so we can cancel it if needed
        window.gameLoopId = requestAnimationFrame(gameLoop);
    }
    
    // Add a function to restart the game
    function restartGame() {
        // First clear any existing game loop to prevent duplicating movement calculations
        if (window.gameLoopId) {
            cancelAnimationFrame(window.gameLoopId);
            window.gameLoopId = null;
        }
        
        // Reset player speed and position
        player = {
            x: 150,
            y: 150,
            angle: 0,
            speed: 0,
            maxSpeed: PLAYER_SPEED, // Make sure we use the constant
            radius: 10,
            rotationSpeed: Math.PI / 60
        };
        
        // Reset game state
        gameOver = false;
        gameWon = false;
        gameStartTime = 0;
        gameTimerStarted = false;
        elapsedTime = 0;
        characterLives = 3; // Explicitly reset character lives to 3
        arrowCount = MAX_ARROWS;
        arrows = [];
        spiders = [];
        nests = [];
        
        // Reset movement flags
        movingForward = false;
        movingBackward = false;
        rotatingLeft = false;
        rotatingRight = false;
        strafingLeft = false;
        strafingRight = false;
        
        // Clear all event listeners to prevent duplicates
        // We'll get new ones in the init function
        document.removeEventListener('keydown', handleKeyDown);
        document.removeEventListener('keyup', handleKeyUp);
        
        // Reset camera
        camera = { x: 0, y: 0 };
        
        // Hide both game over and game won banners
        document.getElementById("gameOverBanner").style.display = "none";
        document.getElementById("gameWonBanner").style.display = "none";
        document.getElementById("gameTimer").style.display = "none";
        
        // Reinitialize the game
        init();

        // Update nest count display after init
        document.getElementById("nestCount").textContent = nests.length;

        // Update UI with reset values
        livesCountDisplay.textContent = characterLives;
    }

    // Start the game
    init();
  </script>
</body>
</html>