<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Maze Game</title>
    <style>
        body {
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: #f0f0f0;
        }
        canvas {
            display: block;
            background-color: white;
            border: 1px solid #ccc;
            outline: none; /* allow focus without outline */
        }
        .game-container {
            position: relative;
        }
        .info {
            position: absolute;
            top: 10px;
            left: 10px;
            font-family: Arial, sans-serif;
            color: #333;
        }
        /* Add focus indicator styling */
        .focus-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0,0,0,0.7);
            color: white;
            padding: 20px;
            border-radius: 10px;
            font-family: Arial, sans-serif;
            text-align: center;
            pointer-events: none; /* Allow clicks to pass through */
            opacity: 0.8;
            transition: opacity 0.5s;
        }
        canvas:focus + .focus-message {
            opacity: 0;
        }
        /* When canvas has focus, add a subtle highlight */
        canvas:focus {
            box-shadow: 0 0 15px 5px rgba(0, 100, 255, 0.5);
        }
        /* Game over banner styling */
        .game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0,0,0,0.8);
            color: white;
            padding: 30px 50px;
            border-radius: 10px;
            font-family: Arial, sans-serif;
            text-align: center;
            z-index: 10;
            border: 3px solid #ff3333;
            display: none;
        }
        .game-over h2 {
            font-size: 32px;
            margin: 0 0 20px 0;
            color: #ff3333;
        }
        .game-over p {
            font-size: 18px;
            margin: 10px 0;
        }
        .game-over button {
            background-color: #ff3333;
            color: white;
            border: none;
            padding: 10px 20px;
            margin-top: 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
        }
        .game-over button:hover {
            background-color: #cc0000;
        }
    </style>
</head>
<body>
  <div class="game-container">
    <canvas id="gameCanvas" tabindex="1"></canvas>
    <div class="focus-message" id="focusMessage">Click here to play<br>(Controls: WASD or Arrows, Space to shoot)</div>
    <div class="game-over" id="gameOverBanner">
        <h2>GAME OVER</h2>
        <p>You were overrun by spiders!</p>
        <button onclick="restartGame()">Play Again</button>
    </div>
    <div class="info">
      Arrows: <span id="arrowCount">3</span><br>
      Lives: <span id="livesCount">3</span><br>
      Spiders: <span id="spiderCount">0</span><br>
      Nests: <span id="nestCount">3</span>
    </div>
  </div>
  <script>
    // Setup canvas
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    const arrowCountDisplay = document.getElementById("arrowCount");
    const livesCountDisplay = document.getElementById("livesCount");
    
    // Add canvas focus handling to capture keyboard events
    canvas.tabIndex = 1;
    
    // Game settings
    const MAZE_COLS = 8;  // Columns in the maze
    const MAZE_ROWS = 8;  // Rows in the maze
    const ROOM_SIZES = [
        { width: 100, height: 100 }, // Small
        { width: 150, height: 150 }, // Medium
        { width: 200, height: 200 }  // Large
    ];
    const MAX_ARROWS = 3; // Changed from 2 to 3
    const ARROW_SPEED = 4;
    const PLAYER_SPEED = 2;
    const WALL_THICKNESS = 1;
    const SPIDER_SIGHT_RANGE = 4 * ROOM_SIZES[0].width; // Spiders see this far
    
    // Game state
    let arrowCount = MAX_ARROWS;
    let arrows = [];
    let walls = [];
    let camera = { x: 0, y: 0 };
    let movingForward = false;
    let movingBackward = false;
    let rotatingLeft = false;
    let rotatingRight = false;
    let characterLives = 3;
    let gameOver = false;
    
    // Initialize canvas size
    function resizeCanvas() {
        canvas.width = window.innerWidth * 0.8;
        canvas.height = window.innerHeight * 0.8;
    }
    
    // Player object
    let player = {
        x: 150,
        y: 150,
        angle: 0, // In radians
        speed: 0,
        maxSpeed: PLAYER_SPEED,
        radius: 10,
        rotationSpeed: Math.PI / 60 // Rotation per frame
    };
    
    // Add function to spawn player at a random non-colliding location
    function spawnPlayer() {
        const mazeWidth = MAZE_COLS * ROOM_SIZES[2].width;
        const mazeHeight = MAZE_ROWS * ROOM_SIZES[2].height;
        let attempts = 0;
        do {
            player.x = player.radius + Math.random() * (mazeWidth - 2 * player.radius);
            player.y = player.radius + Math.random() * (mazeHeight - 2 * player.radius);
            attempts++;
        } while (checkCollision(player.x, player.y) && attempts < 100);
    }

    // Initialize the game
    function init() {
        resizeCanvas();
        generateMaze();
        spawnPlayer();
        // Spawn initial nests (three nests)
        for (let i = 0; i < 3; i++) {
            spawnNest();
        }
        
        // Setup keyboard control handling
        setupControls();
        
        // Start the game loop
        gameLoop();

        // Debug output to help troubleshoot
        console.log("Maze size:", MAZE_COLS * ROOM_SIZES[2].width, "x", MAZE_ROWS * ROOM_SIZES[2].height);
        console.log("Player position:", player.x, player.y);
        console.log("Camera position:", camera.x, camera.y);
        console.log("Canvas size:", canvas.width, canvas.height);

        // Ensure focus works
        canvas.focus();
        console.log("Game initialized, canvas focused:", document.activeElement === canvas);
        
        // Add a click event listener directly to the game container
        document.querySelector('.game-container').addEventListener('click', function() {
            canvas.focus();
            console.log("Game container clicked, canvas focused:", document.activeElement === canvas);
        });

        // Update nest count on start
        document.getElementById("nestCount").textContent = nests.length;
    }
    
    // Generate maze with rooms and walls
    function generateMaze() {
        walls = [];
        
        // First, create the outer boundary
        const mazeWidth = MAZE_COLS * ROOM_SIZES[2].width;
        const mazeHeight = MAZE_ROWS * ROOM_SIZES[2].height;
        const outerWallThickness = 4; // thicker outer walls
        
        // Outer walls (top, right, bottom, left)
        walls.push({x: 0, y: 0, width: mazeWidth, height: outerWallThickness});
        walls.push({x: mazeWidth - outerWallThickness, y: 0, width: outerWallThickness, height: mazeHeight});
        walls.push({x: 0, y: mazeHeight - outerWallThickness, width: mazeWidth, height: outerWallThickness});
        walls.push({x: 0, y: 0, width: outerWallThickness, height: mazeHeight});
        
        // Create random rooms within the maze
        let currentX = 0;
        let currentY = 0;
        
        for (let row = 0; row < MAZE_ROWS; row++) {
            currentX = 0;
            for (let col = 0; col < MAZE_COLS; col++) {
                // Choose a random room size
                const sizeIndex = Math.floor(Math.random() * ROOM_SIZES.length);
                const roomSize = ROOM_SIZES[sizeIndex];
                
                // Create room walls with gaps
                createRoomWalls(currentX, currentY, roomSize.width, roomSize.height);
                
                currentX += roomSize.width;
            }
            
            // Force some walls on the right side to make it less empty
            if (Math.random() > 0.3) { // 70% chance for an extra wall
                const wallHeight = ROOM_SIZES[2].height * 0.6;
                const wallY = currentY + (ROOM_SIZES[2].height - wallHeight) * Math.random();
                walls.push({
                    x: mazeWidth - ROOM_SIZES[0].width * (0.5 + Math.random()),
                    y: wallY,
                    width: WALL_THICKNESS * 2,
                    height: wallHeight
                });
            }
            
            currentY += ROOM_SIZES[2].height; // Use large room height for consistent rows
        }
    }
    
    // Create walls for a single room with random gaps
    function createRoomWalls(x, y, width, height) {
        const gapSize = 30; // Size of gaps in walls
        const wallSegments = 3; // Number of potential wall segments per side
        
        // Top wall
        createWallWithGaps(x, y, width, WALL_THICKNESS, wallSegments, true);
        
        // Right wall
        createWallWithGaps(x + width, y, WALL_THICKNESS, height, wallSegments, false);
        
        // Bottom wall
        createWallWithGaps(x, y + height, width, WALL_THICKNESS, wallSegments, true);
        
        // Left wall
        createWallWithGaps(x, y, WALL_THICKNESS, height, wallSegments, false);
    }
    
    // Create a wall with random gaps
    function createWallWithGaps(x, y, width, height, segments, isHorizontal) {
        const gapProbability = 0.4; // Probability of creating a gap in a segment
        
        if (isHorizontal) {
            const segmentWidth = width / segments;
            for (let i = 0; i < segments; i++) {
                if (Math.random() > gapProbability) {
                    walls.push({
                        x: x + i * segmentWidth,
                        y: y,
                        width: segmentWidth,
                        height: height
                    });
                }
            }
        } else {
            const segmentHeight = height / segments;
            for (let i = 0; i < segments; i++) {
                if (Math.random() > gapProbability) {
                    walls.push({
                        x: x,
                        y: y + i * segmentHeight,
                        width: width,
                        height: segmentHeight
                    });
                }
            }
        }
    }
    
    // Update player position with a much stronger rebound effect equal to player's diameter
    function updatePlayer() {
        if (gameOver) return;
        // Handle rotation
        if (rotatingLeft) {
            player.angle -= player.rotationSpeed;
        }
        if (rotatingRight) {
            player.angle += player.rotationSpeed;
        }
        
        // Determine movement multiplier: forward = 1, backward = -0.5
        let speedMultiplier = 0;
        if (movingForward) {
            speedMultiplier = 1;
        } else if (movingBackward) {
            speedMultiplier = -0.5;
        }
        
        // If turning, reduce effective speed for inertia
        const turning = rotatingLeft || rotatingRight;
        const effectiveSpeed = turning ? player.maxSpeed * 0.7 : player.maxSpeed;
        
        // Compute intended movement delta
        const velocity = effectiveSpeed * speedMultiplier;
        const dx = Math.cos(player.angle) * velocity;
        const dy = Math.sin(player.angle) * velocity;
        const attemptedX = player.x + dx;
        const attemptedY = player.y + dy;
        
        if (!checkCollision(attemptedX, attemptedY)) {
            // No collision: move normally
            player.x = attemptedX;
            player.y = attemptedY;
        } else {
            // Get collision wall for rebound calculation
            const wall = getCollidingWall(attemptedX, attemptedY);
            if (wall) {
                // Calculate rebound that equals the player diameter (2 * radius)
                // Hard rebound in the opposite direction
                const reboundDistance = player.radius * 2;
                
                // Apply strong rebound in direction away from the wall
                // Move away from wall by the full player diameter
                const moveAngle = Math.atan2(dy, dx);
                const oppositeAngle = moveAngle + Math.PI; // 180 degree opposite
                
                // Calculate rebound movement
                const reboundX = Math.cos(oppositeAngle) * reboundDistance;
                const reboundY = Math.sin(oppositeAngle) * reboundDistance;
                
                // Apply rebound - move player back by their diameter
                player.x += reboundX;
                player.y += reboundY;
                
                // Display debug info for rebound
                console.log("Wall rebound applied! Distance:", reboundDistance);
                
                // Skip regular sliding physics when a strong rebound is applied
                updateCamera();
                return;
            }
            
            // Try alternative sliding movements as before
            // Try horizontal slide (0 degrees)
            if (!checkCollision(player.x + dx, player.y)) {
                player.x += dx / 2; // Half speed
            }
            // Try vertical slide (90 degrees) 
            else if (!checkCollision(player.x, player.y + dy)) {
                player.y += dy / 2; // Half speed
            }
            // Try multiple angles between 10-45 degrees
            else {
                // Try +10 degree slide
                const slideAngle10 = moveAngle + Math.PI/18; // +10 degrees
                const dx10 = Math.cos(slideAngle10) * velocity;
                const dy10 = Math.sin(slideAngle10) * velocity;
                
                if (!checkCollision(player.x + dx10, player.y + dy10)) {
                    player.x += dx10 / 3; // Third speed
                    player.y += dy10 / 3;
                } 
                // Try -10 degree slide
                else {
                    const slideAngleMinus10 = moveAngle - Math.PI/18; // -10 degrees
                    const dxMinus10 = Math.cos(slideAngleMinus10) * velocity;
                    const dyMinus10 = Math.sin(slideAngleMinus10) * velocity;
                    
                    if (!checkCollision(player.x + dxMinus10, player.y + dyMinus10)) {
                        player.x += dxMinus10 / 3; // Third speed
                        player.y += dyMinus10 / 3;
                    }
                    // Try +30 degree slide
                    else {
                        const slideAngle30 = moveAngle + Math.PI/6; // +30 degrees
                        const dx30 = Math.cos(slideAngle30) * velocity;
                        const dy30 = Math.sin(slideAngle30) * velocity;
                        
                        if (!checkCollision(player.x + dx30, player.y + dy30)) {
                            player.x += dx30 / 4; // Quarter speed
                            player.y += dy30 / 4;
                        } 
                        // Try -30 degree slide
                        else {
                            const slideAngleMinus30 = moveAngle - Math.PI/6; // -30 degrees
                            const dxMinus30 = Math.cos(slideAngleMinus30) * velocity;
                            const dyMinus30 = Math.sin(slideAngleMinus30) * velocity;
                            
                            if (!checkCollision(player.x + dxMinus30, player.y + dyMinus30)) {
                                player.x += dxMinus30 / 4; // Quarter speed
                                player.y += dyMinus30 / 4;
                            }
                            // Try +45 degree slide as last resort
                            else {
                                const slideAngle45 = moveAngle + Math.PI/4; // +45 degrees
                                const dx45 = Math.cos(slideAngle45) * velocity;
                                const dy45 = Math.sin(slideAngle45) * velocity;
                                
                                if (!checkCollision(player.x + dx45, player.y + dy45)) {
                                    player.x += dx45 / 5; // Fifth speed
                                    player.y += dy45 / 5;
                                } 
                                // Try -45 degree slide
                                else {
                                    const slideAngleMinus45 = moveAngle - Math.PI/4; // -45 degrees
                                    const dxMinus45 = Math.cos(slideAngleMinus45) * velocity;
                                    const dyMinus45 = Math.sin(slideAngleMinus45) * velocity;
                                    
                                    if (!checkCollision(player.x + dxMinus45, player.y + dyMinus45)) {
                                        player.x += dxMinus45 / 5; // Fifth speed
                                        player.y += dyMinus45 / 5;
                                    }
                                    // If none of these work, player stops
                                }
                            }
                        }
                    }
                }
            }
        }
        
        updateCamera();
    }
    
    // Check if player would collide with a wall
    function checkCollision(x, y) {
        for (const wall of walls) {
            // Simple circle vs rectangle collision
            const closestX = Math.max(wall.x, Math.min(x, wall.x + wall.width));
            const closestY = Math.max(wall.y, Math.min(y, wall.y + wall.height));
            
            const distanceX = x - closestX;
            const distanceY = y - closestY;
            const distanceSquared = distanceX * distanceX + distanceY * distanceY;
            
            if (distanceSquared < player.radius * player.radius) {
                return true; // Collision detected
            }
        }
        return false;
    }
    
    // Helper function: Get the wall that player is colliding with
    function getCollidingWall(x, y) {
        for (const wall of walls) {
            const closestX = Math.max(wall.x, Math.min(x, wall.x + wall.width));
            const closestY = Math.max(wall.y, Math.min(y, wall.y + wall.height));
            const dx = x - closestX;
            const dy = y - closestY;
            if ((dx * dx + dy * dy) < player.radius * player.radius) {
                return wall;
            }
        }
        return null;
    }

    // Update camera position to follow player with smooth movement
    function updateCamera() {
        // Immediately position camera on player at start
        if (camera.x === 0 && camera.y === 0) {
            camera.x = player.x - canvas.width / 2;
            camera.y = player.y - canvas.height / 2;
        }

        // Calculate the ideal camera position (centered on player)
        const targetCameraX = player.x - canvas.width / 2;
        const targetCameraY = player.y - canvas.height / 2;
        
        // Calculate the buffer zone (50% of viewport)
        const bufferX = canvas.width * 0.25;
        const bufferY = canvas.height * 0.25;
        
        // Only move camera if player is outside the buffer zone
        if (player.x < camera.x + bufferX) {
            camera.x = player.x - bufferX;
        } else if (player.x > camera.x + canvas.width - bufferX) {
            camera.x = player.x - canvas.width + bufferX;
        }
        
        if (player.y < camera.y + bufferY) {
            camera.y = player.y - bufferY;
        } else if (player.y > camera.y + canvas.height - bufferY) {
            camera.y = player.y - canvas.height + bufferY;
        }
        
        // Add smooth camera movement
        camera.x += (targetCameraX - camera.x) * 0.05;
        camera.y += (targetCameraY - camera.y) * 0.05;
        
        // Ensure camera doesn't go out of bounds
        const mazeWidth = MAZE_COLS * ROOM_SIZES[2].width;
        const mazeHeight = MAZE_ROWS * ROOM_SIZES[2].height;
        
        camera.x = Math.max(0, Math.min(camera.x, mazeWidth - canvas.width));
        camera.y = Math.max(0, Math.min(camera.y, mazeHeight - canvas.height));
    }
    
    // Fire an arrow from the player - simplified for reliability
    function fireArrow() {
        if (gameOver) return;
        console.log("Attempting to fire arrow, count:", arrowCount);
        
        if (arrowCount > 0) {
            // Create a new arrow
            const newArrow = {
                x: player.x,
                y: player.y,
                angle: player.angle,
                speed: ARROW_SPEED,
                stuckTime: 0,
                isStuck: false,
                stuckX: 0,
                stuckY: 0
            };
            
            // Add arrow to array
            arrows.push(newArrow);
            
            // Decrease arrow count and update display
            arrowCount--;
            arrowCountDisplay.textContent = arrowCount;
            
            console.log("Arrow fired! Remaining:", arrowCount);
        }
    }
    
    // Update arrows (movement and collision) - shorten range by 20%
    function updateArrows() {
        if (gameOver) return;
        for (let i = arrows.length - 1; i >= 0; i--) {
            const arrow = arrows[i];
            
            if (arrow.isStuck) {
                // If arrow is stuck in a wall, count down its "stuck time"
                arrow.stuckTime++;
                if (arrow.stuckTime > 120) { // 2 seconds at 60fps
                    arrows.splice(i, 1);
                    arrowCount++;
                    arrowCountDisplay.textContent = arrowCount;
                }
                continue;
            }
            
            // Move the arrow
            const newX = arrow.x + Math.cos(arrow.angle) * arrow.speed;
            const newY = arrow.y + Math.sin(arrow.angle) * arrow.speed;
            
            // Check for collision with walls
            let collision = false;
            for (const wall of walls) {
                // Line vs rectangle collision (simplified)
                // Check if the arrow's path intersects with the wall
                const lineStart = { x: arrow.x, y: arrow.y };
                const lineEnd = { x: newX, y: newY };
                
                // Check each edge of the wall
                if (lineIntersectsRect(lineStart, lineEnd, wall)) {
                    arrow.isStuck = true;
                    arrow.stuckTime = 0;
                    // Position the arrow at the wall
                    const intersection = findIntersection(lineStart, lineEnd, wall);
                    arrow.stuckX = intersection.x;
                    arrow.stuckY = intersection.y;
                    collision = true;
                    break;
                }
            }
            
            if (!collision) {
                arrow.x = newX;
                arrow.y = newY;
                
                // Check if arrow has traveled too far (reduced by 20% from 1/3 to ~1/4 of window width)
                const distanceTraveled = Math.sqrt(
                    Math.pow(arrow.x - player.x, 2) + Math.pow(arrow.y - player.y, 2)
                );
                if (distanceTraveled > window.innerWidth / 3 * 0.8) { // 20% shorter range
                    arrows.splice(i, 1);
                    arrowCount++;
                    arrowCountDisplay.textContent = arrowCount;
                }
            }
        }
    }
    
    // Helper function: Find if a line intersects with a rectangle
    function lineIntersectsRect(lineStart, lineEnd, rect) {
        // Check intersection with each edge of the rectangle
        const rectLines = [
            { start: {x: rect.x, y: rect.y}, end: {x: rect.x + rect.width, y: rect.y} },
            { start: {x: rect.x + rect.width, y: rect.y}, end: {x: rect.x + rect.width, y: rect.y + rect.height} },
            { start: {x: rect.x + rect.width, y: rect.y + rect.height}, end: {x: rect.x, y: rect.y + rect.height} },
            { start: {x: rect.x, y: rect.y + rect.height}, end: {x: rect.x, y: rect.y} }
        ];
        
        for (const line of rectLines) {
            if (linesIntersect(lineStart, lineEnd, line.start, line.end)) {
                return true;
            }
        }
        return false;
    }
    
    // Helper function: Find if two lines intersect
    function linesIntersect(a, b, c, d) {
        const denominator = ((b.y - a.y) * (d.x - c.x)) - ((b.x - a.x) * (d.y - c.y));
        
        if (denominator === 0) {
            return false;
        }
        
        const ua = (((b.x - a.x) * (c.y - a.y)) - ((b.y - a.y) * (c.x - a.x))) / denominator;
        const ub = (((d.x - c.x) * (c.y - a.y)) - ((d.y - c.y) * (c.x - a.x))) / denominator;
        
        return (ua >= 0 && ua <= 1) && (ub >= 0 && ub <= 1);
    }
    
    // Helper function: Find the intersection point of a line and a wall
    function findIntersection(lineStart, lineEnd, rect) {
        // This is a simplified version - just returns a point near the wall
        // In a full implementation, you'd calculate the exact intersection point
        return {
            x: lineEnd.x,
            y: lineEnd.y
        };
    }
    
    // New functions for handling nests and spiders
    let nests = [];
    let spiders = [];

    // Update spawnNest to properly avoid wall collisions
    function spawnNest() {
        const mazeWidth = MAZE_COLS * ROOM_SIZES[2].width;
        const mazeHeight = MAZE_ROWS * ROOM_SIZES[2].height;
        let attempts = 0;
        let nestX, nestY;
        const nestRadius = 20; // Size of nest for collision checking
        
        // Keep trying positions until we find one without wall collision
        do {
            nestX = nestRadius + Math.random() * (mazeWidth - 2 * nestRadius);
            nestY = nestRadius + Math.random() * (mazeHeight - 2 * nestRadius);
            attempts++;
            
            // Debug output to track attempts
            if (attempts > 50) {
                console.log("Warning: Many attempts to place nest without wall collision");
            }
        } while (nestCollidesWithWall(nestX, nestY, nestRadius) && attempts < 100);
        
        nests.push({
            x: nestX,
            y: nestY,
            hp: 3,
            lastSpawnTime: performance.now() - 25000 // Initialize 25 seconds ago to spawn first spider soon
        });
        
        console.log("Nest created at position:", nestX, nestY);
        document.getElementById("nestCount").textContent = nests.length;
    }

    // Add helper function to check nest-wall collisions
    function nestCollidesWithWall(x, y, radius) {
        for (const wall of walls) {
            // Circle vs rectangle collision check
            const closestX = Math.max(wall.x, Math.min(x, wall.x + wall.width));
            const closestY = Math.max(wall.y, Math.min(y, wall.y + wall.height));
            
            const distanceX = x - closestX;
            const distanceY = y - closestY;
            const distanceSquared = distanceX * distanceX + distanceY * distanceY;
            
            if (distanceSquared < radius * radius) {
                return true; // Collision detected
            }
        }
        return false;
    }

    // Make spawnSpiders more reliable with better logging and shorter interval
    function spawnSpiders() {
        if (gameOver) return;
        const currentTime = performance.now();
        nests.forEach((nest, index) => {
            // Check if nest has lastSpawnTime property
            if (!nest.lastSpawnTime) {
                nest.lastSpawnTime = currentTime - 25000; // Initialize if missing
                console.log("Fixed missing lastSpawnTime for nest", index);
            }
            
            // Reduced spawn time to 15 seconds for testing (15000ms)
            if (currentTime - nest.lastSpawnTime >= 15000) {
                spiders.push({
                    x: nest.x,
                    y: nest.y,
                    speed: 0.5,
                    angle: Math.random() * 2 * Math.PI
                });
                nest.lastSpawnTime = currentTime;
                console.log("Spider spawned from nest", index, "at time:", currentTime);
                document.getElementById("spiderCount").textContent = spiders.length;
            }
        });
    }

    // Update updateSpiders to use similar wall collision logic as the player
    function updateSpiders() {
        if (gameOver) return;
        spiders.forEach((spider, index) => {
            const dx = player.x - spider.x;
            const dy = player.y - spider.y;
            const distance = Math.hypot(dx, dy);

            if (distance < SPIDER_SIGHT_RANGE) {
                spider.state = 'chasing';
                // Reduce chase speed by 25% (from 1.2 to 0.9)
                spider.speed = PLAYER_SPEED * 0.9; // 25% slower than before
                
                // Check if there's a direct line of sight to the player
                const hasLineOfSight = !walls.some(wall => 
                    lineIntersectsRect({x: spider.x, y: spider.y}, {x: player.x, y: player.y}, wall)
                );
                
                if (hasLineOfSight) {
                    // Direct path available, move straight toward player
                    spider.angle = Math.atan2(dy, dx);
                } else {
                    // No direct line of sight, use goal seeking
                    // Either keep current direction or try to find a better angle
                    const currentAngle = spider.angle;
                    
                    // Try several angles and pick the best one
                    const angles = [
                        currentAngle,
                        Math.atan2(dy, dx), // Direct to player
                        currentAngle + Math.PI/6, // +30 degrees
                        currentAngle - Math.PI/6, // -30 degrees
                        currentAngle + Math.PI/3, // +60 degrees
                        currentAngle - Math.PI/3, // -60 degrees
                        currentAngle + Math.PI/2, // +90 degrees
                        currentAngle - Math.PI/2  // -90 degrees
                    ];
                    
                    // Score each angle by how much closer it gets to the player
                    let bestScore = -Infinity;
                    let bestAngle = currentAngle;
                    
                    for (const angle of angles) {
                        const testX = spider.x + Math.cos(angle) * spider.speed * 5; // Look ahead
                        const testY = spider.y + Math.sin(angle) * spider.speed * 5;
                        
                        // Skip if this would hit a wall
                        if (checkCollision(testX, testY)) continue;
                        
                        // Score based on new distance to player
                        const newDx = player.x - testX;
                        const newDy = player.y - testY;
                        const newDist = Math.hypot(newDx, newDy);
                        
                        // Score is how much closer we get to player
                        const score = distance - newDist;
                        
                        if (score > bestScore) {
                            bestScore = score;
                            bestAngle = angle;
                        }
                    }
                    
                    // Gradually adjust toward best angle
                    spider.angle = currentAngle + (bestAngle - currentAngle) * 0.2;
                }
            } else {
                // Wander randomly
                spider.state = 'wandering';
                // Reduce wandering speed by 25% (from 0.5 to 0.375)
                spider.speed = 0.375; // 25% slower than before
                spider.angle += (Math.random() - 0.5) * 0.1;
            }

            const newX = spider.x + Math.cos(spider.angle) * spider.speed;
            const newY = spider.y + Math.sin(spider.angle) * spider.speed;
            
            // Apply similar wall collision logic as the player
            if (!checkCollision(newX, newY)) {
                // No collision, move normally
                spider.x = newX;
                spider.y = newY;
            } else {
                // Try sliding along walls like the player does
                const moveAngle = spider.angle;
                
                // Try horizontal slide
                if (!checkCollision(spider.x + Math.cos(spider.angle) * spider.speed, spider.y)) {
                    spider.x += Math.cos(spider.angle) * spider.speed / 2;
                }
                // Try vertical slide
                else if (!checkCollision(spider.x, spider.y + Math.sin(spider.angle) * spider.speed)) {
                    spider.y += Math.sin(spider.angle) * spider.speed / 2;
                }
                // Try +30 degree
                else {
                    const slideAngle30 = moveAngle + Math.PI/6;
                    const dx30 = Math.cos(slideAngle30) * spider.speed;
                    const dy30 = Math.sin(slideAngle30) * spider.speed;
                    
                    if (!checkCollision(spider.x + dx30, spider.y + dy30)) {
                        spider.x += dx30 / 2;
                        spider.y += dy30 / 2;
                    } 
                    // Try -30 degree
                    else {
                        const slideAngleMinus30 = moveAngle - Math.PI/6;
                        const dxMinus30 = Math.cos(slideAngleMinus30) * spider.speed;
                        const dyMinus30 = Math.sin(slideAngleMinus30) * spider.speed;
                        
                        if (!checkCollision(spider.x + dxMinus30, spider.y + dyMinus30)) {
                            spider.x += dxMinus30 / 2;
                            spider.y += dyMinus30 / 2;
                        }
                        // If all else fails, just change direction significantly
                        else {
                            spider.angle += Math.PI * (0.5 + Math.random() * 0.5);
                        }
                    }
                }
            }

            // Check collision with player
            if (Math.hypot(player.x - spider.x, player.y - spider.y) < player.radius + 5) {
                characterLives--;
                livesCountDisplay.textContent = characterLives;
                spiders.splice(index, 1);
                if (characterLives <= 0) {
                    gameOver = true;
                    console.log("Game Over!");
                    // Show the game over banner
                    document.getElementById("gameOverBanner").style.display = "block";
                }
            }
        });
    }

    // Update checkArrowCollisions to prevent killing through walls
    function checkArrowCollisions() {
        if (gameOver) return;
        for (let i = arrows.length - 1; i >= 0; i--) {
            const arrow = arrows[i];
            
            // Check arrow collision with spiders
            for (let j = spiders.length - 1; j >= 0; j--) {
                const spider = spiders[j];
                
                // First check if they're close enough
                if (Math.hypot(arrow.x - spider.x, arrow.y - spider.y) < 11) { // Reduced from 15
                    
                    // Then check if there's a wall between them
                    const lineBlocked = walls.some(wall => 
                        lineIntersectsRect(
                            {x: arrow.x, y: arrow.y}, 
                            {x: spider.x, y: spider.y}, 
                            wall
                        )
                    );
                    
                    // Only kill the spider if no walls are in the way
                    if (!lineBlocked) {
                        spiders.splice(j, 1);
                        arrows.splice(i, 1);
                        arrowCount++;
                        arrowCountDisplay.textContent = arrowCount;
                        break;
                    }
                }
            }
            
            // Check nest collisions (unchanged)
            for (let k = 0; k < nests.length; k++) {
                const nest = nests[k];
                const distance = Math.sqrt(Math.pow(arrow.x - nest.x, 2) + Math.pow(arrow.y - nest.y, 2));
                if (distance < 25) { // Nest radius
                    nest.hp--;
                    arrows.splice(i, 1);
                    arrowCount++;
                    arrowCountDisplay.textContent = arrowCount;
                    if (nest.hp <= 0) {
                        nests.splice(k, 1);
                        console.log("Nest destroyed!");
                        document.getElementById("nestCount").textContent = nests.length;
                    }
                    break;
                }
            }
        }
    }

    // Update drawBaddies to make spiders 30% smaller
    function drawBaddies() {
        // Draw nests as purple circles
        nests.forEach(nest => {
            ctx.fillStyle = 'purple';
            ctx.beginPath();
            ctx.arc(nest.x, nest.y, 20, 0, 2 * Math.PI);
            ctx.fill();
        });

        // Draw spiders as hollow red circles with legs (30% smaller)
        spiders.forEach(spider => {
            ctx.save();
            ctx.translate(spider.x, spider.y);
            
            // Spider body - 30% smaller (7px radius instead of 10px)
            const spiderRadius = 7;
            ctx.beginPath();
            ctx.arc(0, 0, spiderRadius, 0, 2 * Math.PI);
            ctx.strokeStyle = 'red';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // Draw 8 legs around the body - 30% shorter
            const legOuterLength = 11; // Reduced from 16
            for (let i = 0; i < 8; i++) {
                const angle = i * Math.PI / 4;
                ctx.beginPath();
                ctx.moveTo(Math.cos(angle) * spiderRadius, Math.sin(angle) * spiderRadius);
                ctx.lineTo(Math.cos(angle) * legOuterLength, Math.sin(angle) * legOuterLength);
                ctx.strokeStyle = 'red';
                ctx.lineWidth = 1;
                ctx.stroke();
            }
            
            ctx.restore();
        });
    }

    // Draw the game world
    function render() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.save();
        // Apply camera transformation
        ctx.translate(-camera.x, -camera.y);
        
        // Draw walls
        ctx.fillStyle = 'black';
        for (const wall of walls) {
            // Only draw walls that are potentially visible
            if (wall.x + wall.width >= camera.x && 
                wall.x <= camera.x + canvas.width &&
                wall.y + wall.height >= camera.y && 
                wall.y <= camera.y + canvas.height) {
                ctx.fillRect(wall.x, wall.y, wall.width, wall.height);
            }
        }
        
        // Draw outer boundary
        const mazeWidth = MAZE_COLS * ROOM_SIZES[2].width;
        const mazeHeight = MAZE_ROWS * ROOM_SIZES[2].height;
        ctx.strokeStyle = 'white';
        ctx.lineWidth = 6;
        ctx.strokeRect(0, 0, mazeWidth, mazeHeight);
        
        // Draw arrows
        for (const arrow of arrows) {
            ctx.save();
            if (arrow.isStuck) {
                // Draw stuck arrow
                ctx.translate(arrow.stuckX, arrow.stuckY);
                ctx.rotate(arrow.angle);
                // Arrow body
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(-10, 0);
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 2;
                ctx.stroke();
                // Arrow head
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(-4, 3);
                ctx.lineTo(-4, -3);
                ctx.closePath();
                ctx.fillStyle = 'black';
                ctx.fill();
            } else {
                // Draw moving arrow
                ctx.translate(arrow.x, arrow.y);
                ctx.rotate(arrow.angle);
                // Arrow body
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(-10, 0);
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 2;
                ctx.stroke();
                // Arrow head
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(-4, 3);
                ctx.lineTo(-4, -3);
                ctx.closePath();
                ctx.fillStyle = 'black';
                ctx.fill();
            }
            ctx.restore();
        }
        
        // Draw player
        ctx.save();
        ctx.translate(player.x, player.y);
        ctx.rotate(player.angle);
        // Player circle
        ctx.beginPath();
        ctx.arc(0, 0, player.radius, 0, Math.PI * 2);
        ctx.fillStyle = 'black';
        ctx.fill();
        // Direction indicator (arrow)
        ctx.beginPath();
        ctx.moveTo(player.radius, 0);
        ctx.lineTo(player.radius - 5, -5);
        ctx.lineTo(player.radius - 5, 5);
        ctx.closePath();
        ctx.fillStyle = 'white';
        ctx.fill();
        ctx.restore();
        
        // Draw baddies
        drawBaddies();
        
        // Restore camera transformation
        ctx.restore();
        
        // Update UI elements
        arrowCountDisplay.textContent = arrowCount;
        livesCountDisplay.textContent = characterLives;
        document.getElementById("spiderCount").textContent = spiders.length;
    }

    // Handle keyboard input - improved event handling for both canvas and window
    function setupControls() {
        // Make document always handle keyboard events regardless of focus
        const keyHandler = (e, isKeyDown) => {
            // Process key events
            if (e.key === 'w' || e.key === 'ArrowUp') {
                movingForward = isKeyDown;
                e.preventDefault();
            }
            if (e.key === 's' || e.key === 'ArrowDown') {
                movingBackward = isKeyDown;
                e.preventDefault();
            }
            if (e.key === 'a' || e.key === 'ArrowLeft') {
                rotatingLeft = isKeyDown;
                e.preventDefault();
            }
            if (e.key === 'd' || e.key === 'ArrowRight') {
                rotatingRight = isKeyDown;
                e.preventDefault();
            }
            if (isKeyDown && (e.key === 'f' || e.key === ' ')) {
                fireArrow();
                e.preventDefault();
            }
            
            // Attempt to focus canvas on any key press
            if (isKeyDown && !canvas.matches(':focus')) {
                canvas.focus();
            }
        };

        document.addEventListener('keydown', e => keyHandler(e, true));
        document.addEventListener('keyup', e => keyHandler(e, false));
        
        // Make focus more reliable
        canvas.tabIndex = 1; // Ensure canvas can receive focus
        
        // Focus canvas when clicked
        document.addEventListener('click', function() {
            canvas.focus();
            console.log("Click detected, canvas focused:", document.activeElement === canvas);
        });
        
        // Force focus on page load
        window.addEventListener('load', function() {
            setTimeout(() => {
                canvas.focus();
                console.log("Page loaded, focus set to canvas:", document.activeElement === canvas);
            }, 100);
        });
        
        // Handle window resize
        window.addEventListener('resize', resizeCanvas);
    }
    
    // Modify gameLoop to call spawnSpiders so nests generate spiders over time
    function gameLoop() {
        updatePlayer();
        updateArrows();
        spawnSpiders();
        updateSpiders();
        checkArrowCollisions();
        render();
        // Output the number of spiders
        console.log("Number of spiders:", spiders.length);
        requestAnimationFrame(gameLoop);
    }
    
    // Add a function to restart the game
    function restartGame() {
        // Reset game state
        gameOver = false;
        characterLives = 3;
        arrowCount = MAX_ARROWS;
        arrows = [];
        spiders = [];
        nests = [];
        
        // Hide the game over banner
        document.getElementById("gameOverBanner").style.display = "none";
        
        // Reinitialize the game
        init();

        // Update nest count display after init
        document.getElementById("nestCount").textContent = nests.length;
    }

    // Start the game
    init();
  </script>
</body>
</html>