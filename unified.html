<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Maze Game</title>
    <style>
        body {
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: #f0f0f0;
        }
        canvas {
            display: block;
            background-color: white;
            border: 1px solid #ccc;
            outline: none; /* allow focus without outline */
        }
        .game-container {
            position: relative;
        }
        .info {
            position: absolute;
            top: 10px;
            left: 10px;
            font-family: Arial, sans-serif;
            color: #333;
        }
        /* Add focus indicator styling */
        .focus-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0,0,0,0.7);
            color: white;
            padding: 20px;
            border-radius: 10px;
            font-family: Arial, sans-serif;
            text-align: center;
            pointer-events: none; /* Allow clicks to pass through */
            opacity: 0.8;
            transition: opacity 0.5s;
        }
        canvas:focus + .focus-message {
            opacity: 0;
        }
        /* When canvas has focus, add a subtle highlight */
        canvas:focus {
            box-shadow: 0 0 15px 5px rgba(0, 100, 255, 0.5);
        }
        /* Game over banner styling */
        .game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0,0,0,0.8);
            color: white;
            padding: 30px 50px;
            border-radius: 10px;
            font-family: Arial, sans-serif;
            text-align: center;
            z-index: 10;
            border: 3px solid #ff3333;
            display: none;
        }
        .game-over h2 {
            font-size: 32px;
            margin: 0 0 20px 0;
            color: #ff3333;
        }
        .game-over p {
            font-size: 18px;
            margin: 10px 0;
        }
        .game-over button {
            background-color: #ff3333;
            color: white;
            border: none;
            padding: 10px 20px;
            margin-top: 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
        }
        .game-over button:hover {
            background-color: #cc0000;
        }
        /* Game won banner styling */
        .game-won {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0,0,0,0.8);
            color: white;
            padding: 30px 50px;
            border-radius: 10px;
            font-family: Arial, sans-serif;
            text-align: center;
            z-index: 10;
            border: 3px solid #33cc33;
            display: none;
        }
        .game-won h2 {
            font-size: 32px;
            margin: 0 0 20px 0;
            color: #33cc33;
        }
        .game-won p {
            font-size: 18px;
            margin: 10px 0;
        }
        .game-won button {
            background-color: #33cc33;
            color: white;
            border: none;
            padding: 10px 20px;
            margin-top: 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
        }
        .game-won button:hover {
            background-color: #29a329;
        }
        
        /* Timer styling */
        .timer {
            position: absolute;
            top: 10px;
            right: 10px;
            font-family: Arial, sans-serif;
            color: #333;
            background: rgba(255,255,255,0.7);
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 16px;
        }
    </style>
</head>
<body>
  <div class="game-container">
    <canvas id="gameCanvas" tabindex="1"></canvas>
    <div class="focus-message" id="focusMessage">Click here to play<br>(WASD or Arrows to move, < and > to strafe, Space to shoot)</div>
    <div class="game-over" id="gameOverBanner">
        <h2>GAME OVER</h2>
        <p>You were overrun by spiders!</p>
        <p>Time: <span id="timePlayedLoss">0:00</span></p>
        <button onclick="restartGame()">Play Again</button>
    </div>
    <div class="game-won" id="gameWonBanner">
        <h2>VICTORY!</h2>
        <p>You destroyed all spider nests!</p>
        <p>Time: <span id="timePlayedWin">0:00</span></p>
        <button onclick="restartGame()">Play Again</button>
    </div>
    <div class="timer" id="gameTimer">Time: 0:00</div>
    <div class="info">
      Arrows: <span id="arrowCount">3</span><br>
      Lives: <span id="livesCount">3</span><br>
      Spiders: <span id="spiderCount">0</span><br>
      Nests: <span id="nestCount">3</span>
    </div>
  </div>
  <script>
    // Setup canvas
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    const arrowCountDisplay = document.getElementById("arrowCount");
    const livesCountDisplay = document.getElementById("livesCount");
    
    // Add canvas focus handling to capture keyboard events
    canvas.tabIndex = 1;
    
    // Debug mode initialization - add this near the top of the script
    window.debugMode = false;
    
    // Game settings
    const MAZE_COLS = 8;  // Columns in the maze
    const MAZE_ROWS = 8;  // Rows in the maze
    const ROOM_SIZES = [
        { width: 100, height: 100 }, // Small
        { width: 150, height: 150 }, // Medium
        { width: 200, height: 200 }  // Large
    ];
    const MAX_ARROWS = 3; // Changed from 2 to 3
    const ARROW_SPEED = 4;
    const PLAYER_SPEED = 2;
    const WALL_THICKNESS = 1;
    const SPIDER_SIGHT_RANGE = 4 * ROOM_SIZES[0].width; // Spiders see this far
    
    // Game state
    let arrowCount = MAX_ARROWS;
    let arrows = [];
    let walls = [];
    let camera = { x: 0, y: 0 };
    let movingForward = false;
    let movingBackward = false;
    let rotatingLeft = false;
    let rotatingRight = false;
    let strafingLeft = false;   // New state for strafing movement
    let strafingRight = false;  // New state for strafing movement
    let characterLives = 3;
    let gameOver = false;
    let gameWon = false;        // New flag for win condition
    let gameStartTime = 0;      // When the game started
    let gameTimerStarted = false; // Flag to track if timer has started
    let gameEndTime = 0;        // When game ended
    let elapsedTime = 0;        // Current elapsed time
    
    // Spider AI constants - add death animation properties
    const SPIDER_STATES = {
        PATROL: 'patrol',
        ATTACK: 'attack',
        RETREAT: 'retreat',
        HEAL: 'heal',
        DYING: 'dying'  // New state for death animation
    };
    const SPIDER_PATROL_RANGE = 250; // Increased from 150 for wider wandering
    const SPIDER_DETECTION_RANGE = 250; // Distance at which spiders can detect player
    const SPIDER_CHASE_RANGE = 350; // Distance at which spiders will stop chasing
    const SPIDER_MAX_HEALTH = 3; // Maximum spider health
    const SPIDER_HEAL_TIME = 3000; // Time to heal in milliseconds
    const SPIDER_DEATH_ANIMATION_TIME = 1000; // Time for death animation in milliseconds

    // Initialize canvas size
    function resizeCanvas() {
        canvas.width = window.innerWidth * 0.8;
        canvas.height = window.innerHeight * 0.8;
    }
    
    // Player object
    let player = {
        x: 150,
        y: 150,
        angle: 0, // In radians
        speed: 0,
        maxSpeed: PLAYER_SPEED,
        radius: 10,
        rotationSpeed: Math.PI / 60 // Rotation per frame
    };
    
    // Add function to spawn player at a random non-colliding location
    function spawnPlayer() {
        const mazeWidth = MAZE_COLS * ROOM_SIZES[2].width;
        const mazeHeight = MAZE_ROWS * ROOM_SIZES[2].height;
        let attempts = 0;
        do {
            player.x = player.radius + Math.random() * (mazeWidth - 2 * player.radius);
            player.y = player.radius + Math.random() * (mazeHeight - 2 * player.radius);
            attempts++;
        } while (checkCollision(player.x, player.y) && attempts < 100);
    }

    // Initialize the game
    function init() {
        resizeCanvas();
        generateMaze();
        spawnPlayer();
        
        // Reset game timer state
        gameStartTime = 0;
        gameTimerStarted = false;
        gameWon = false;
        gameOver = false;
        
        // Create exactly 3 nests
        nests = [];
        while (nests.length < 3) {
            spawnNest();
        }
        
        // Setup keyboard control handling
        setupControls();
        
        // Start the game loop
        gameLoop();

        // Debug output to help troubleshoot
        console.log("Maze size:", MAZE_COLS * ROOM_SIZES[2].width, "x", MAZE_ROWS * ROOM_SIZES[2].height);
        console.log("Player position:", player.x, player.y);
        console.log("Camera position:", camera.x, camera.y);
        console.log("Canvas size:", canvas.width, canvas.height);

        // Ensure focus works
        canvas.focus();
        console.log("Game initialized, canvas focused:", document.activeElement === canvas);
        
        // Add a click event listener directly to the game container
        document.querySelector('.game-container').addEventListener('click', function() {
            canvas.focus();
            console.log("Game container clicked, canvas focused:", document.activeElement === canvas);
        });

        // Update nest count on start
        document.getElementById("nestCount").textContent = nests.length;

        // Update focus message to include new controls
        document.getElementById("focusMessage").innerHTML = 
            "Click here to play<br>(WASD or Arrows to move/rotate, A/D to strafe, Space to shoot)";
        
        // Hide timer initially - will show on first movement
        document.getElementById("gameTimer").style.display = "none";
    }
    
    // Generate maze with rooms and walls
    function generateMaze() {
        walls = [];
        
        // First, create the outer boundary
        const mazeWidth = MAZE_COLS * ROOM_SIZES[2].width;
        const mazeHeight = MAZE_ROWS * ROOM_SIZES[2].height;
        const outerWallThickness = 4; // thicker outer walls
        
        // Outer walls (top, right, bottom, left)
        walls.push({x: 0, y: 0, width: mazeWidth, height: outerWallThickness});
        walls.push({x: mazeWidth - outerWallThickness, y: 0, width: outerWallThickness, height: mazeHeight});
        walls.push({x: 0, y: mazeHeight - outerWallThickness, width: mazeWidth, height: outerWallThickness});
        walls.push({x: 0, y: 0, width: outerWallThickness, height: mazeHeight});
        
        // Create random rooms within the maze
        let currentX = 0;
        let currentY = 0;
        
        for (let row = 0; row < MAZE_ROWS; row++) {
            currentX = 0;
            for (let col = 0; col < MAZE_COLS; col++) {
                // Choose a random room size
                const sizeIndex = Math.floor(Math.random() * ROOM_SIZES.length);
                const roomSize = ROOM_SIZES[sizeIndex];
                
                // Create room walls with gaps
                createRoomWalls(currentX, currentY, roomSize.width, roomSize.height);
                
                currentX += roomSize.width;
            }
            
            // Force some walls on the right side to make it less empty
            if (Math.random() > 0.3) { // 70% chance for an extra wall
                const wallHeight = ROOM_SIZES[2].height * 0.6;
                const wallY = currentY + (ROOM_SIZES[2].height - wallHeight) * Math.random();
                walls.push({
                    x: mazeWidth - ROOM_SIZES[0].width * (0.5 + Math.random()),
                    y: wallY,
                    width: WALL_THICKNESS * 2,
                    height: wallHeight
                });
            }
            
            currentY += ROOM_SIZES[2].height; // Use large room height for consistent rows
        }
    }
    
    // Create walls for a single room with random gaps
    function createRoomWalls(x, y, width, height) {
        const gapSize = 30; // Size of gaps in walls
        const wallSegments = 3; // Number of potential wall segments per side
        
        // Top wall
        createWallWithGaps(x, y, width, WALL_THICKNESS, wallSegments, true);
        
        // Right wall
        createWallWithGaps(x + width, y, WALL_THICKNESS, height, wallSegments, false);
        
        // Bottom wall
        createWallWithGaps(x, y + height, width, WALL_THICKNESS, wallSegments, true);
        
        // Left wall
        createWallWithGaps(x, y, WALL_THICKNESS, height, wallSegments, false);
    }
    
    // Create a wall with random gaps - increased minimum gap size
    function createWallWithGaps(x, y, width, height, segments, isHorizontal) {
        const gapProbability = 0.4; // Probability of creating a gap in a segment
        const minGapSize = 30; // Minimum gap size for player to pass through (player diameter is 20)
        
        if (isHorizontal) {
            const segmentWidth = width / segments;
            // Ensure segments are wide enough for gaps
            if (segmentWidth < minGapSize * 2) {
                // If segments are too small, create fewer but larger segments
                const adjustedSegments = Math.max(1, Math.floor(width / (minGapSize * 2)));
                const adjustedSegmentWidth = width / adjustedSegments;
                
                for (let i = 0; i < adjustedSegments; i++) {
                    if (Math.random() > gapProbability) {
                        walls.push({
                            x: x + i * adjustedSegmentWidth,
                            y: y,
                            width: adjustedSegmentWidth - minGapSize, // Ensure gap is at least minGapSize
                            height: height
                        });
                    }
                }
            } else {
                // Original logic with guaranteed minimum gap size
                for (let i = 0; i < segments; i++) {
                    if (Math.random() > gapProbability) {
                        walls.push({
                            x: x + i * segmentWidth,
                            y: y,
                            width: segmentWidth - minGapSize, // Ensure gap is at least minGapSize
                            height: height
                        });
                    }
                }
            }
        } else {
            const segmentHeight = height / segments;
            // Ensure segments are tall enough for gaps
            if (segmentHeight < minGapSize * 2) {
                // If segments are too small, create fewer but larger segments
                const adjustedSegments = Math.max(1, Math.floor(height / (minGapSize * 2)));
                const adjustedSegmentHeight = height / adjustedSegments;
                
                for (let i = 0; i < adjustedSegments; i++) {
                    if (Math.random() > gapProbability) {
                        walls.push({
                            x: x,
                            y: y + i * adjustedSegmentHeight,
                            width: width,
                            height: adjustedSegmentHeight - minGapSize // Ensure gap is at least minGapSize
                        });
                    }
                }
            } else {
                // Original logic with guaranteed minimum gap size
                for (let i = 0; i < segments; i++) {
                    if (Math.random() > gapProbability) {
                        walls.push({
                            x: x,
                            y: y + i * segmentHeight,
                            width: width,
                            height: segmentHeight - minGapSize // Ensure gap is at least minGapSize
                        });
                    }
                }
            }
        }
    }
    
    // Update player position with improved strafing logic
    function updatePlayer() {
        if (gameOver || gameWon) return;
        
        // Start timer on first movement
        if (!gameTimerStarted && (movingForward || movingBackward || rotatingLeft || 
            rotatingRight || strafingLeft || strafingRight)) {
            gameStartTime = performance.now();
            gameTimerStarted = true;
            document.getElementById("gameTimer").style.display = "block";
            console.log("Game timer started!");
        }
        
        // Handle rotation
        if (rotatingLeft) {
            player.angle -= player.rotationSpeed;
        }
        if (rotatingRight) {
            player.angle += player.rotationSpeed;
        }
        
        // Normalize angle
        player.angle = ((player.angle % (2 * Math.PI)) + 2 * Math.PI) % (2 * Math.PI);
        
        // Calculate movement vectors using direct calculations
        // Forward vector is based on player angle
        const dx = Math.cos(player.angle);
        const dy = Math.sin(player.angle);
        
        // Calculate perpendicular vector (RIGHT direction)
        const rightX = -dy;
        const rightY = dx;
        
        // Use simplified strafing logic with ternary operators
        const angleDeg = player.angle * 180 / Math.PI;
        const isFacingDown = angleDeg > 0 && angleDeg < 180;
        
        // Simplified strafe direction calculation
        const strafeRightX = isFacingDown ? -rightX : rightX;
        const strafeRightY = isFacingDown ? -rightY : rightY;
        
        if (window.debugMode) {
            console.log(`Angle: ${Math.round(angleDeg)}°, 
                        Facing down: ${isFacingDown}, 
                        Strafe right vector: (${strafeRightX.toFixed(2)}, ${strafeRightY.toFixed(2)})`);
        }
        
        // Initialize movement with zero
        let moveX = 0;
        let moveY = 0;
        
        // Add forward/backward movement
        if (movingForward) {
            moveX += dx * player.maxSpeed;
            moveY += dy * player.maxSpeed;
        }
        if (movingBackward) {
            moveX -= dx * player.maxSpeed * 0.5;
            moveY -= dy * player.maxSpeed * 0.5;
        }
        
        // Apply strafe movement using the simplified vectors
        if (strafingLeft) {
            moveX -= strafeRightX * player.maxSpeed * 0.8;
            moveY -= strafeRightY * player.maxSpeed * 0.8;
        }
        if (strafingRight) {
            moveX += strafeRightX * player.maxSpeed * 0.8;
            moveY += strafeRightY * player.maxSpeed * 0.8;
        }
        
        // Try to move
        let newX = player.x + moveX;
        let newY = player.y + moveY;
        
        // Check for collisions and handle movement
        if (!checkCollision(newX, newY)) {
            // No collision, move normally
            player.x = newX;
            player.y = newY;
        } else {
            // Try horizontal movement only
            if (!checkCollision(player.x + moveX, player.y)) {
                player.x += moveX;
            } 
            // Try vertical movement only
            else if (!checkCollision(player.x, player.y + moveY)) {
                player.y += moveY;
            }
            // If both fail, player is stuck
        }
        
        updateCamera();
    }

    // Check if player would collide with a wall
    function checkCollision(x, y) {
        for (const wall of walls) {
            // Simple circle vs rectangle collision
            const closestX = Math.max(wall.x, Math.min(x, wall.x + wall.width));
            const closestY = Math.max(wall.y, Math.min(y, wall.y + wall.height));
            
            const distanceX = x - closestX;
            const distanceY = y - closestY;
            const distanceSquared = distanceX * distanceX + distanceY * distanceY;
            
            if (distanceSquared < player.radius * player.radius) {
                return true; // Collision detected
            }
        }
        return false;
    }
    
    // Helper function: Get the wall that player is colliding with
    function getCollidingWall(x, y) {
        for (const wall of walls) {
            const closestX = Math.max(wall.x, Math.min(x, wall.x + wall.width));
            const closestY = Math.max(wall.y, Math.min(y, wall.y + wall.height));
            const dx = x - closestX;
            const dy = y - closestY;
            if ((dx * dx + dy * dy) < player.radius * player.radius) {
                return wall;
            }
        }
        return null;
    }

    // Update camera position to follow player with smooth movement
    function updateCamera() {
        // Immediately position camera on player at start
        if (camera.x === 0 && camera.y === 0) {
            camera.x = player.x - canvas.width / 2;
            camera.y = player.y - canvas.height / 2;
        }

        // Calculate the ideal camera position (centered on player)
        const targetCameraX = player.x - canvas.width / 2;
        const targetCameraY = player.y - canvas.height / 2;
        
        // Calculate the buffer zone (50% of viewport)
        const bufferX = canvas.width * 0.25;
        const bufferY = canvas.height * 0.25;
        
        // Only move camera if player is outside the buffer zone
        if (player.x < camera.x + bufferX) {
            camera.x = player.x - bufferX;
        } else if (player.x > camera.x + canvas.width - bufferX) {
            camera.x = player.x - canvas.width + bufferX;
        }
        
        if (player.y < camera.y + bufferY) {
            camera.y = player.y - bufferY;
        } else if (player.y > camera.y + canvas.height - bufferY) {
            camera.y = player.y - canvas.height + bufferY;
        }
        
        // Add smooth camera movement
        camera.x += (targetCameraX - camera.x) * 0.05;
        camera.y += (targetCameraY - camera.y) * 0.05;
        
        // Ensure camera doesn't go out of bounds
        const mazeWidth = MAZE_COLS * ROOM_SIZES[2].width;
        const mazeHeight = MAZE_ROWS * ROOM_SIZES[2].height;
        
        camera.x = Math.max(0, Math.min(camera.x, mazeWidth - canvas.width));
        camera.y = Math.max(0, Math.min(camera.y, mazeHeight - canvas.height));
    }
    
    // Fire an arrow from the player - simplified for reliability
    function fireArrow() {
        if (gameOver) return;
        console.log("Attempting to fire arrow, count:", arrowCount);
        
        if (arrowCount > 0) {
            // Create a new arrow
            const newArrow = {
                x: player.x,
                y: player.y,
                angle: player.angle,
                speed: ARROW_SPEED,
                stuckTime: 0,
                isStuck: false,
                stuckX: 0,
                stuckY: 0
            };
            
            // Add arrow to array
            arrows.push(newArrow);
            
            // Decrease arrow count and update display
            arrowCount--;
            arrowCountDisplay.textContent = arrowCount;
            
            console.log("Arrow fired! Remaining:", arrowCount);
        }
    }
    
    // Update arrows (movement and collision) - shorten range by 20%
    function updateArrows() {
        if (gameOver) return;
        for (let i = arrows.length - 1; i >= 0; i--) {
            const arrow = arrows[i];
            
            if (arrow.isStuck) {
                // If arrow is stuck in a wall, count down its "stuck time"
                arrow.stuckTime++;
                if (arrow.stuckTime > 120) { // 2 seconds at 60fps
                    arrows.splice(i, 1);
                    arrowCount++;
                    arrowCountDisplay.textContent = arrowCount;
                }
                continue;
            }
            
            // Move the arrow
            const newX = arrow.x + Math.cos(arrow.angle) * arrow.speed;
            const newY = arrow.y + Math.sin(arrow.angle) * arrow.speed;
            
            // Check for collision with walls
            let collision = false;
            for (const wall of walls) {
                // Line vs rectangle collision (simplified)
                // Check if the arrow's path intersects with the wall
                const lineStart = { x: arrow.x, y: arrow.y };
                const lineEnd = { x: newX, y: newY };
                
                // Check each edge of the wall
                if (lineIntersectsRect(lineStart, lineEnd, wall)) {
                    arrow.isStuck = true;
                    arrow.stuckTime = 0;
                    // Position the arrow at the wall
                    const intersection = findIntersection(lineStart, lineEnd, wall);
                    arrow.stuckX = intersection.x;
                    arrow.stuckY = intersection.y;
                    collision = true;
                    break;
                }
            }
            
            if (!collision) {
                arrow.x = newX;
                arrow.y = newY;
                
                // Check if arrow has traveled too far (reduced by 20% from 1/3 to ~1/4 of window width)
                const distanceTraveled = Math.sqrt(
                    Math.pow(arrow.x - player.x, 2) + Math.pow(arrow.y - player.y, 2)
                );
                if (distanceTraveled > window.innerWidth / 3 * 0.8) { // 20% shorter range
                    arrows.splice(i, 1);
                    arrowCount++;
                    arrowCountDisplay.textContent = arrowCount;
                }
            }
        }
    }
    
    // Helper function: Find if a line intersects with a rectangle
    function lineIntersectsRect(lineStart, lineEnd, rect) {
        // Check intersection with each edge of the rectangle
        const rectLines = [
            { start: {x: rect.x, y: rect.y}, end: {x: rect.x + rect.width, y: rect.y} },
            { start: {x: rect.x + rect.width, y: rect.y}, end: {x: rect.x + rect.width, y: rect.y + rect.height} },
            { start: {x: rect.x + rect.width, y: rect.y + rect.height}, end: {x: rect.x, y: rect.y + rect.height} },
            { start: {x: rect.x, y: rect.y + rect.height}, end: {x: rect.x, y: rect.y} }
        ];
        
        for (const line of rectLines) {
            if (linesIntersect(lineStart, lineEnd, line.start, line.end)) {
                return true;
            }
        }
        return false;
    }
    
    // Helper function: Find if two lines intersect
    function linesIntersect(a, b, c, d) {
        const denominator = ((b.y - a.y) * (d.x - c.x)) - ((b.x - a.x) * (d.y - c.y));
        
        if (denominator === 0) {
            return false;
        }
        
        const ua = (((b.x - a.x) * (c.y - a.y)) - ((b.y - a.y) * (c.x - a.x))) / denominator;
        const ub = (((d.x - c.x) * (c.y - a.y)) - ((d.y - c.y) * (c.x - a.x))) / denominator;
        
        return (ua >= 0 && ua <= 1) && (ub >= 0 && ub <= 1);
    }
    
    // Helper function: Find the intersection point of a line and a wall
    function findIntersection(lineStart, lineEnd, rect) {
        // This is a simplified version - just returns a point near the wall
        // In a full implementation, you'd calculate the exact intersection point
        return {
            x: lineEnd.x,
            y: lineEnd.y
        };
    }
    
    // New functions for handling nests and spiders
    let nests = [];
    let spiders = [];

    // Update spawnNest to properly avoid wall collisions
    function spawnNest() {
        const mazeWidth = MAZE_COLS * ROOM_SIZES[2].width;
        const mazeHeight = MAZE_ROWS * ROOM_SIZES[2].height;
        let attempts = 0;
        let nestX, nestY;
        const nestRadius = 20; // Size of nest for collision checking
        
        // Keep trying positions until we find one without wall collision
        do {
            nestX = nestRadius + Math.random() * (mazeWidth - 2 * nestRadius);
            nestY = nestRadius + Math.random() * (mazeHeight - 2 * nestRadius);
            attempts++;
            
            // Debug output to track attempts
            if (attempts > 50) {
                console.log("Warning: Many attempts to place nest without wall collision");
            }
        } while (nestCollidesWithWall(nestX, nestY, nestRadius) && attempts < 100);
        
        nests.push({
            x: nestX,
            y: nestY,
            hp: 3,
            lastSpawnTime: performance.now() - 25000 // Initialize 25 seconds ago to spawn first spider soon
        });
        
        console.log("Nest created at position:", nestX, nestY);
        document.getElementById("nestCount").textContent = nests.length;
    }

    // Add helper function to check nest-wall collisions
    function nestCollidesWithWall(x, y, radius) {
        for (const wall of walls) {
            // Circle vs rectangle collision check
            const closestX = Math.max(wall.x, Math.min(x, wall.x + wall.width));
            const closestY = Math.max(wall.y, Math.min(y, wall.y + wall.height));
            
            const distanceX = x - closestX;
            const distanceY = y - closestY;
            const distanceSquared = distanceX * distanceX + distanceY * distanceY;
            
            if (distanceSquared < radius * radius) {
                return true; // Collision detected
            }
        }
        return false;
    }

    // Make spawnSpiders more reliable with better logging and shorter interval
    function spawnSpiders() {
        if (gameOver) return;
        const currentTime = performance.now();
        nests.forEach((nest, index) => {
            // Check if nest has lastSpawnTime property
            if (!nest.lastSpawnTime) {
                nest.lastSpawnTime = currentTime - 25000; // Initialize if missing
                console.log("Fixed missing lastSpawnTime for nest", index);
            }
            
            // Reduced spawn time to 15 seconds for testing (15000ms)
            if (currentTime - nest.lastSpawnTime >= 15000) {
                // Give the spider a slight initial offset from the nest center
                // This helps them start moving immediately
                const offsetAngle = Math.random() * 2 * Math.PI;
                const offsetDist = 5 + Math.random() * 15; // Start 5-20 pixels away from nest
                const startX = nest.x + Math.cos(offsetAngle) * offsetDist;
                const startY = nest.y + Math.sin(offsetAngle) * offsetDist;
                
                // Initial patrol direction that takes them away from the nest
                const initialPatrolAngle = offsetAngle; // Continue in same direction as offset
                
                spiders.push({
                    x: startX, 
                    y: startY,
                    speed: 0.5,
                    angle: initialPatrolAngle,
                    state: SPIDER_STATES.PATROL,
                    nestX: nest.x,     // Remember origin nest position
                    nestY: nest.y,
                    patrolAngle: initialPatrolAngle, // Use the outward angle
                    patrolDistance: offsetDist,      // Track initial distance
                    lastStateChange: currentTime,
                    lastDirectionChange: currentTime + 3000, // Delay first direction change
                    forcedPatrolOutward: true,       // Flag to force initial outward movement
                    forcePatrolTime: currentTime + 2000, // Force outward movement for 2 seconds
                    health: SPIDER_MAX_HEALTH,
                    healStartTime: 0,
                    opacity: 1.0,
                    deathStartTime: 0
                });
                nest.lastSpawnTime = currentTime;
                console.log("Spider spawned from nest", index, "at time:", currentTime);
                document.getElementById("spiderCount").textContent = spiders.length;
            }
        });
    }

    // Enhanced spider update function with improved nest finding behavior
    function updateSpiders() {
        if (gameOver) return;
        const currentTime = performance.now();
        
        // Filter out spiders that have completed death animation
        spiders = spiders.filter(spider => {
            if (spider.state === SPIDER_STATES.DYING) {
                // Check if death animation is complete
                const deathProgress = currentTime - spider.deathStartTime;
                if (deathProgress >= SPIDER_DEATH_ANIMATION_TIME) {
                    console.log("Spider removed after death animation");
                    return false; // Remove from array
                }
            }
            return true; // Keep in array
        });
        
        spiders.forEach((spider, index) => {
            // Handle death animation
            if (spider.state === SPIDER_STATES.DYING) {
                const deathProgress = currentTime - spider.deathStartTime;
                spider.opacity = 1 - (deathProgress / SPIDER_DEATH_ANIMATION_TIME);
                return; // Skip other logic for dying spiders
            }
            
            // Calculate distance to player
            const dx = player.x - spider.x;
            const dy = player.y - spider.y;
            const distanceToPlayer = Math.hypot(dx, dy);
            
            // Find the current target nest (original nest or nearest alternative)
            let targetNest = findTargetNest(spider);
            
            // If there are no nests left, spider can't heal (will fight to the death)
            const canHeal = targetNest !== null;
            
            // Calculate distance to target nest
            let dxNest = 0, dyNest = 0, distanceToNest = Infinity;
            if (targetNest) {
                dxNest = targetNest.x - spider.x;
                dyNest = targetNest.y - spider.y;
                distanceToNest = Math.hypot(dxNest, dyNest);
                
                // Update spider's healing destination if needed
                if (spider.nestX !== targetNest.x || spider.nestY !== targetNest.y) {
                    spider.nestX = targetNest.x;
                    spider.nestY = targetNest.y;
                    if (window.debugMode) {
                        console.log("Spider reassigned to new nest at", targetNest.x, targetNest.y);
                    }
                }
            }
            
            // Line of sight check
            const hasLineOfSight = !walls.some(wall => 
                lineIntersectsRect({x: spider.x, y: spider.y}, {x: player.x, y: player.y}, wall)
            );
            
            // Update spider state based on current state and conditions
            switch(spider.state) {
                case SPIDER_STATES.PATROL:
                    // Check if player is detected
                    if (distanceToPlayer < SPIDER_DETECTION_RANGE && hasLineOfSight) {
                        spider.state = SPIDER_STATES.ATTACK;
                        spider.lastStateChange = currentTime;
                        console.log("Spider switched to attack state");
                        // Clear forced patrol flag when changing state
                        spider.forcedPatrolOutward = false;
                        break;
                    }
                    
                    // Check if initial forced outward movement period is over
                    if (spider.forcedPatrolOutward && currentTime > spider.forcePatrolTime) {
                        spider.forcedPatrolOutward = false;
                        console.log("Spider finished forced outward patrol");
                    }
                    
                    // Change direction occasionally or if getting too far from nest
                    const shouldChangeDirection = 
                        (!spider.forcedPatrolOutward && // Skip during forced patrol
                         ((currentTime - spider.lastDirectionChange > 3000) || // Every 3 seconds
                          (distanceToNest > SPIDER_PATROL_RANGE)));            // Or if too far from nest
                          
                    if (shouldChangeDirection) {
                        if (distanceToNest > SPIDER_PATROL_RANGE * 0.8) {
                            // If near patrol boundary, head back toward nest
                            // Add more randomness to make paths less predictable
                            const randomAngleOffset = (Math.random() - 0.5) * Math.PI; // ±90 degrees
                            spider.patrolAngle = Math.atan2(dyNest, dxNest) + randomAngleOffset;
                        } else {
                            // Otherwise pick a new random direction
                            spider.patrolAngle = Math.random() * 2 * Math.PI;
                        }
                        spider.lastDirectionChange = currentTime;
                    }
                    
                    // Set movement angle to patrol angle
                    spider.angle = spider.patrolAngle;
                    
                    // Use slightly faster patrol speed to help them leave nest area
                    spider.speed = spider.forcedPatrolOutward ? 0.5 : 0.375;
                    break;
                    
                case SPIDER_STATES.RETREAT:
                    // If there's no nest to retreat to, switch to attack mode
                    if (!canHeal) {
                        spider.state = SPIDER_STATES.ATTACK;
                        spider.lastStateChange = currentTime;
                        console.log("Spider can't find nest to heal - fighting to the death!");
                        break;
                    }
                    
                    // Check if reached nest center 
                    if (distanceToNest < 10) {
                        spider.state = SPIDER_STATES.HEAL;
                        spider.healStartTime = currentTime;
                        spider.lastStateChange = currentTime;
                        console.log("Spider reached nest and starts healing");
                        
                        // Ensure spider is exactly at nest center for healing
                        spider.x = spider.nestX;
                        spider.y = spider.nestY;
                        break;
                    }
                    
                    // Set angle toward nest center
                    spider.angle = Math.atan2(dyNest, dxNest);
                    
                    // Check if there are obstacles between spider and nest
                    const pathToNestBlocked = walls.some(wall => 
                        lineIntersectsRect(
                            {x: spider.x, y: spider.y}, 
                            {x: spider.nestX, y: spider.nestY}, 
                            wall
                        )
                    );
                    
                    if (pathToNestBlocked) {
                        // Use pathfinding to navigate around obstacles
                        // ...existing pathfinding code...
                    }
                    
                    // Move faster when retreating
                    spider.speed = 0.7;
                    break;
                    
                // ...existing code for other states...
            }
            
            // The rest of the spider update logic
            // ...existing code...
        });
        
        // Update the spider count display
        document.getElementById("spiderCount").textContent = spiders.length;
    }

    // Helper function to find the best nest for a spider to heal
    function findTargetNest(spider) {
        // First check if the spider's original nest still exists
        let originalNestExists = false;
        let originalNestIndex = -1;
        
        for (let i = 0; i < nests.length; i++) {
            if (nests[i].x === spider.nestX && nests[i].y === spider.nestY) {
                originalNestExists = true;
                originalNestIndex = i;
                break;
            }
        }
        
        // If the original nest still exists, use it
        if (originalNestExists) {
            return nests[originalNestIndex];
        }
        
        // If we have no nests left, return null
        if (nests.length === 0) {
            return null;
        }
        
        // Find the closest nest
        let closestNest = nests[0];
        let closestDistance = Math.hypot(
            nests[0].x - spider.x,
            nests[0].y - spider.y
        );
        
        for (let i = 1; i < nests.length; i++) {
            const distance = Math.hypot(
                nests[i].x - spider.x,
                nests[i].y - spider.y
            );
            
            if (distance < closestDistance) {
                closestDistance = distance;
                closestNest = nests[i];
            }
        }
        
        return closestNest;
    }

    // Update checkArrowCollisions to handle spider health and death animation
    function checkArrowCollisions() {
        if (gameOver) return;
        for (let i = arrows.length - 1; i >= 0; i--) {
            const arrow = arrows[i];
            
            // Check arrow collision with spiders
            for (let j = spiders.length - 1; j >= 0; j--) {
                const spider = spiders[j];
                
                // Skip spiders that are already dying
                if (spider.state === SPIDER_STATES.DYING) continue;
                
                // First check if they're close enough
                if (Math.hypot(arrow.x - spider.x, arrow.y - spider.y) < 11) { // Reduced from 15
                    
                    // Then check if there's a wall between them
                    const lineBlocked = walls.some(wall => 
                        lineIntersectsRect(
                            {x: arrow.x, y: arrow.y}, 
                            {x: spider.x, y: spider.y}, 
                            wall
                        )
                    );
                    
                    // Only hit the spider if no walls are in the way
                    if (!lineBlocked) {
                        // Reduce spider health
                        spider.health--;
                        console.log("Spider hit! Health:", spider.health);
                        
                        // Change state to retreat if health is critical
                        if (spider.health === 1) {
                            spider.state = SPIDER_STATES.RETREAT;
                            spider.lastStateChange = performance.now();
                            console.log("Spider retreating to nest!");
                        }
                        
                        // Start death animation if health is depleted
                        if (spider.health <= 0) {
                            spider.state = SPIDER_STATES.DYING;
                            spider.deathStartTime = performance.now();
                            spider.opacity = 1.0; // Start fully visible
                            spider.speed = 0; // Stop moving
                            console.log("Spider dying!");
                        }
                        
                        // Remove arrow in any case
                        arrows.splice(i, 1);
                        arrowCount++;
                        arrowCountDisplay.textContent = arrowCount;
                        break;
                    }
                }
            }
            
            // Check nest collisions (unchanged)
            for (let k = 0; k < nests.length; k++) {
                const nest = nests[k];
                const distance = Math.sqrt(Math.pow(arrow.x - nest.x, 2) + Math.pow(arrow.y - nest.y, 2));
                if (distance < 25) { // Nest radius
                    nest.hp--;
                    arrows.splice(i, 1);
                    arrowCount++;
                    arrowCountDisplay.textContent = arrowCount;
                    if (nest.hp <= 0) {
                        nests.splice(k, 1);
                        console.log("Nest destroyed!");
                        document.getElementById("nestCount").textContent = nests.length;
                        
                        // Check win condition immediately when last nest is destroyed
                        if (nests.length === 0 && spiders.length === 0) {
                            checkWinCondition();
                        }
                    }
                    break;
                }
            }
        }
    }

    // Draw spiders with visual indication of their state
    function drawBaddies() {
        // Draw nests as purple circles
        nests.forEach(nest => {
            ctx.fillStyle = 'purple';
            ctx.beginPath();
            ctx.arc(nest.x, nest.y, 20, 0, 2 * Math.PI);
            ctx.fill();
        });

        // Draw spiders with different colors based on state
        spiders.forEach(spider => {
            ctx.save();
            ctx.translate(spider.x, spider.y);
            
            // Set opacity for death animation
            if (spider.state === SPIDER_STATES.DYING) {
                ctx.globalAlpha = spider.opacity;
            }
            
            // Spider body - 30% smaller (7px radius instead of 10px)
            const spiderRadius = 7;
            ctx.beginPath();
            ctx.arc(0, 0, spiderRadius, 0, 2 * Math.PI);
            
            // Change color based on state
            switch(spider.state) {
                case SPIDER_STATES.PATROL:
                    ctx.strokeStyle = 'orange'; // Orange for patrol
                    break;
                case SPIDER_STATES.ATTACK:
                    ctx.strokeStyle = 'red';    // Red for attack
                    break;
                case SPIDER_STATES.RETREAT:
                    ctx.strokeStyle = 'gray';   // Gray for retreat
                    break;
                case SPIDER_STATES.HEAL:
                    ctx.strokeStyle = 'green';  // Green for healing
                    break;
                case SPIDER_STATES.DYING:
                    ctx.strokeStyle = 'darkred'; // Darker red for dying
                    break;
            }
            
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // Draw health indicators (except for dying spiders)
            if (spider.state !== SPIDER_STATES.DYING) {
                for (let i = 0; i < SPIDER_MAX_HEALTH; i++) {
                    const healthX = (i - 1) * 5 - 2;
                    const healthY = -spiderRadius - 5;
                    ctx.beginPath();
                    ctx.rect(healthX, healthY, 4, 2);
                    
                    // Show filled or empty health bars
                    if (i < spider.health) {
                        ctx.fillStyle = 'red';
                        ctx.fill();
                    } else {
                        ctx.strokeStyle = 'darkred';
                        ctx.stroke();
                    }
                }
            }
            
            // Draw 8 legs around the body - 30% shorter
            const legOuterLength = 11; // Reduced from 16
            for (let i = 0; i < 8; i++) {
                const angle = i * Math.PI / 4;
                ctx.beginPath();
                ctx.moveTo(Math.cos(angle) * spiderRadius, Math.sin(angle) * spiderRadius);
                ctx.lineTo(Math.cos(angle) * legOuterLength, Math.sin(angle) * legOuterLength);
                
                // Legs match body color
                if (spider.state === SPIDER_STATES.DYING) {
                    ctx.strokeStyle = 'darkred';
                } else {
                    ctx.strokeStyle = 
                        spider.state === SPIDER_STATES.PATROL ? 'orange' : 
                        spider.state === SPIDER_STATES.ATTACK ? 'red' :
                        spider.state === SPIDER_STATES.RETREAT ? 'gray' : 'green';
                }
                ctx.lineWidth = 1;
                ctx.stroke();
            }
            
            // Draw direction indicator (except for dying spiders)
            if (spider.state !== SPIDER_STATES.DYING) {
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(Math.cos(spider.angle) * (spiderRadius + 5), 
                          Math.sin(spider.angle) * (spiderRadius + 5));
                ctx.strokeStyle = 'white';
                ctx.stroke();
            }
            
            ctx.restore();
        });
    }

    // Draw the game world
    function render() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.save();
        
        // Apply camera transform
        ctx.translate(-camera.x, -camera.y);
        
        // Draw game elements (walls, boundaries, arrows, player, baddies)
        // Draw walls
        ctx.fillStyle = 'black';
        for (const wall of walls) {
            // Only draw walls that are potentially visible
            if (wall.x + wall.width >= camera.x && 
                wall.x <= camera.x + canvas.width &&
                wall.y + wall.height >= camera.y && 
                wall.y <= camera.y + canvas.height) {
                ctx.fillRect(wall.x, wall.y, wall.width, wall.height);
            }
        }
        
        // Draw outer boundary
        const mazeWidth = MAZE_COLS * ROOM_SIZES[2].width;
        const mazeHeight = MAZE_ROWS * ROOM_SIZES[2].height;
        ctx.strokeStyle = 'white';
        ctx.lineWidth = 6;
        ctx.strokeRect(0, 0, mazeWidth, mazeHeight);
        
        // Draw arrows
        for (const arrow of arrows) {
            ctx.save();
            if (arrow.isStuck) {
                // Draw stuck arrow
                ctx.translate(arrow.stuckX, arrow.stuckY);
                ctx.rotate(arrow.angle);
                // Arrow body
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(-10, 0);
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 2;
                ctx.stroke();
                // Arrow head
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(-4, 3);
                ctx.lineTo(-4, -3);
                ctx.closePath();
                ctx.fillStyle = 'black';
                ctx.fill();
            } else {
                // Draw moving arrow
                ctx.translate(arrow.x, arrow.y);
                ctx.rotate(arrow.angle);
                // Arrow body
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(-10, 0);
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 2;
                ctx.stroke();
                // Arrow head
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(-4, 3);
                ctx.lineTo(-4, -3);
                ctx.closePath();
                ctx.fillStyle = 'black';
                ctx.fill();
            }
            ctx.restore();
        }
        
        // Draw player
        ctx.save();
        ctx.translate(player.x, player.y);
        ctx.rotate(player.angle);
        
        // Draw player circle
        ctx.beginPath();
        ctx.arc(0, 0, player.radius, 0, Math.PI * 2);
        ctx.fillStyle = 'black';
        ctx.fill();
        
        // Draw direction indicator
        ctx.beginPath();
        ctx.moveTo(player.radius, 0);
        ctx.lineTo(player.radius - 5, -5);
        ctx.lineTo(player.radius - 5, 5);
        ctx.closePath();
        ctx.fillStyle = 'white';
        ctx.fill();
        ctx.restore();
        
        // Draw debug indicators if enabled
        if (window.debugMode) {
            drawDebugIndicators();
        }
        
        // Draw baddies
        drawBaddies();
        
        ctx.restore(); // Restore from camera transform
        
        // Draw debug mode indicator in screen space
        if (window.debugMode) {
            ctx.fillStyle = "rgba(0,0,0,0.5)";
            ctx.fillRect(canvas.width - 110, 5, 105, 24);
            ctx.font = "16px Arial";
            ctx.fillStyle = "#00ff00";
            ctx.fillText("DEBUG MODE", canvas.width - 100, 22);
        }
        
        // Update UI elements
        arrowCountDisplay.textContent = arrowCount;
        livesCountDisplay.textContent = characterLives;
        document.getElementById("spiderCount").textContent = spiders.length;
    }

    // Updated control handling with better debug mode toggle
    function setupControls() {
        // Clean up existing handlers
        if (window.handleKeyDown) {
            document.removeEventListener('keydown', window.handleKeyDown);
        }
        if (window.handleKeyUp) {
            document.removeEventListener('keyup', window.handleKeyUp);
        }
        
        // Define handlers
        window.handleKeyDown = function(e) {
            handleKey(e, true);
        };
        
        window.handleKeyUp = function(e) {
            handleKey(e, false);
        };
        
        function handleKey(e, isDown) {
            // Special case for debug toggle - always check this regardless of game state
            if (isDown && (e.key === '`' || e.key === 'Backquote' || e.code === 'Backquote' || e.key === 'd' && e.altKey)) {
                window.debugMode = !window.debugMode;
                console.log("Debug mode toggled:", window.debugMode ? "ON" : "OFF");
                e.preventDefault();
                return;
            }
            
            // Ignore other inputs when game is over
            if (gameOver || gameWon) return;
            
            // Reset strafing to avoid key combinations interfering
            if (e.key === 'a' || e.key === 'd' || e.key === ',' || e.key === '.' || 
                e.key === '<' || e.key === '>') {
                if (!isDown) {
                    // Only reset the specific key that was released
                    if (e.key === 'a' || e.key === '<' || e.key === ',') {
                        strafingLeft = false;
                    }
                    if (e.key === 'd' || e.key === '>' || e.key === '.') {
                        strafingRight = false;
                    }
                }
            }
            
            // Clear movement state
            if (e.key === 'w' || e.key === 's' || e.key === 'ArrowUp' || e.key === 'ArrowDown') {
                if (!isDown) {
                    if (e.key === 'w' || e.key === 'ArrowUp') {
                        movingForward = false;
                    }
                    if (e.key === 's' || e.key === 'ArrowDown') {
                        movingBackward = false;
                    }
                }
            }
            
            // Clear rotation state
            if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
                if (!isDown) {
                    if (e.key === 'ArrowLeft') {
                        rotatingLeft = false;
                    }
                    if (e.key === 'ArrowRight') {
                        rotatingRight = false;
                    }
                }
            }
            
            // Regular game controls - separate if blocks to avoid overriding
            switch(e.key) {
                case 'w': 
                case 'ArrowUp':
                    if (isDown) movingForward = true;
                    break;
                case 's': 
                case 'ArrowDown':
                    if (isDown) movingBackward = true;
                    break;
                case 'a': // KEY CHANGE: Always handle strafe for A key regardless of rotation
                    if (isDown) {
                        strafingLeft = true;
                        if (window.debugMode) console.log("STRAFE LEFT");
                    }
                    break;
                case 'd': // KEY CHANGE: Always handle strafe for D key regardless of rotation
                    if (isDown) {
                        strafingRight = true;
                        if (window.debugMode) console.log("STRAFE RIGHT");
                    }
                    break;
                case 'ArrowLeft':
                    if (isDown) rotatingLeft = true;
                    break;
                case 'ArrowRight':
                    if (isDown) rotatingRight = true;
                    break;
                case ',':
                case '<':
                    if (isDown) strafingLeft = true;
                    break;
                case '.':
                case '>':
                    if (isDown) strafingRight = true;
                    break;
                case ' ':
                case 'f':
                    if (isDown) fireArrow();
                    break;
            }
            
            // Debug key states when in debug mode
            if (window.debugMode && isDown) {
                console.log("Movement state:", {
                    forward: movingForward,
                    backward: movingBackward,
                    strafeLeft: strafingLeft, 
                    strafeRight: strafingRight,
                    rotateLeft: rotatingLeft,
                    rotateRight: rotatingRight
                });
            }
            
            // Prevent default browser behaviors for game keys
            e.preventDefault();
            
            // Hide focus message on any keypress
            if (isDown) {
                const focusMessage = document.getElementById("focusMessage");
                if (focusMessage) {
                    focusMessage.style.opacity = "0";
                }
            }
        }
        
        // Add event listeners
        document.addEventListener('keydown', window.handleKeyDown);
        document.addEventListener('keyup', window.handleKeyUp);
        
        // Canvas click handler
        canvas.addEventListener('click', function() {
            canvas.focus();
            document.getElementById("focusMessage").style.opacity = "0";
        });
        
        // Window resize handler
        window.addEventListener('resize', resizeCanvas);
    }

    // Add a test function to help debug - can be called from browser console
    function testStrafe() {
        // Calculate the right vector
        const angle = player.angle;
        const dx = Math.cos(angle);
        const dy = Math.sin(angle);
        const rightX = -dy;
        const rightY = dx;
        
        console.log(`
        Player angle: ${Math.round(angle * 180 / Math.PI)}°
        Forward vector: (${dx.toFixed(2)}, ${dy.toFixed(2)})
        Right vector: (${rightX.toFixed(2)}, ${rightY.toFixed(2)})
        Strafe Left: ${strafingLeft}
        Strafe Right: ${strafingRight}
        `);
        
        // Test movement calculations
        const moveX = rightX * player.maxSpeed * 0.8;
        const moveY = rightY * player.maxSpeed * 0.8;
        
        console.log(`
        If strafing right, would move: (${moveX.toFixed(2)}, ${moveY.toFixed(2)})
        If strafing left, would move: (${(-moveX).toFixed(2)}, ${(-moveY).toFixed(2)})
        `);
    }
    
    // Add function to update timer display
    function updateTimer() {
        if (!gameTimerStarted) return "0:00";
        
        const currentTime = performance.now();
        elapsedTime = Math.floor((currentTime - gameStartTime) / 1000); // Time in seconds
        
        // Format time as minutes:seconds
        const minutes = Math.floor(elapsedTime / 60);
        const seconds = elapsedTime % 60;
        const formattedTime = `${minutes}:${seconds.toString().padStart(2, '0')}`;
        
        // Update timer display if game is active
        if (!gameOver && !gameWon) {
            document.getElementById("gameTimer").textContent = `Time: ${formattedTime}`;
        }
        
        return formattedTime;
    }

    // Add function to check for win condition
    function checkWinCondition() {
        // Win when all nests are destroyed and no spiders remain
        if (!gameOver && !gameWon && nests.length === 0 && spiders.length === 0) {
            gameWon = true;
            gameEndTime = performance.now();
            
            // Calculate final time
            const finalTime = updateTimer();
            
            // Show win banner with time
            document.getElementById("timePlayedWin").textContent = finalTime;
            document.getElementById("gameWonBanner").style.display = "block";
            
            console.log("Victory! Game completed in", finalTime);
        }
    }
    
    // Modify gameLoop to check for win condition and update timer
    function gameLoop() {
        updatePlayer();
        updateArrows();
        spawnSpiders();
        updateSpiders();
        checkArrowCollisions();
        
        // Check win condition and update timer
        checkWinCondition();
        if (gameTimerStarted) {
            updateTimer();
        }
        
        render();
        
        // Store the animation frame ID so we can cancel it if needed
        window.gameLoopId = requestAnimationFrame(gameLoop);
    }
    
    // Add a function to restart the game
    function restartGame() {
        // First clear any existing game loop to prevent duplicating movement calculations
        if (window.gameLoopId) {
            cancelAnimationFrame(window.gameLoopId);
            window.gameLoopId = null;
        }
        
        // Reset player speed and position
        player = {
            x: 150,
            y: 150,
            angle: 0,
            speed: 0,
            maxSpeed: PLAYER_SPEED, // Make sure we use the constant
            radius: 10,
            rotationSpeed: Math.PI / 60
        };
        
        // Reset game state
        gameOver = false;
        gameWon = false;
        gameStartTime = 0;
        gameTimerStarted = false;
        elapsedTime = 0;
        characterLives = 3; // Explicitly reset character lives to 3
        arrowCount = MAX_ARROWS;
        arrows = [];
        spiders = [];
        nests = [];
        
        // Reset movement flags
        movingForward = false;
        movingBackward = false;
        rotatingLeft = false;
        rotatingRight = false;
        strafingLeft = false;
        strafingRight = false;
        
        // Clear all event listeners to prevent duplicates
        // We'll get new ones in the init function
        document.removeEventListener('keydown', handleKeyDown);
        document.removeEventListener('keyup', handleKeyUp);
        
        // Reset camera
        camera = { x: 0, y: 0 };
        
        // Hide both game over and game won banners
        document.getElementById("gameOverBanner").style.display = "none";
        document.getElementById("gameWonBanner").style.display = "none";
        document.getElementById("gameTimer").style.display = "none";
        
        // Reinitialize the game
        init();

        // Update nest count display after init
        document.getElementById("nestCount").textContent = nests.length;

        // Update UI with reset values
        livesCountDisplay.textContent = characterLives;
    }

    // Draw debug indicators to help visualize movement directions
    function drawDebugIndicators() {
        // Only draw in debug mode
        if (!window.debugMode) return;
        
        ctx.save();
        ctx.translate(player.x, player.y);
        
        // Forward direction (green)
        const fwdX = Math.cos(player.angle) * 40;
        const fwdY = Math.sin(player.angle) * 40;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(fwdX, fwdY);
        ctx.strokeStyle = 'green';
        ctx.lineWidth = 3;
        ctx.stroke();
        
        // Calculate strafe vectors with the compact code
        const rightX = -Math.sin(player.angle);
        const rightY = Math.cos(player.angle);
        const angleDeg = player.angle * 180 / Math.PI;
        const isFacingDown = angleDeg > 0 && angleDeg < 180;
        
        // Use ternary operators for more concise code
        const strafeRightX = isFacingDown ? -rightX : rightX;
        const strafeRightY = isFacingDown ? -rightY : rightY;
        
        // Calculate the angle for active strafing (if any)
        const strafeAngle = strafingLeft ? 
            Math.atan2(-strafeRightY, -strafeRightX) : 
            Math.atan2(strafeRightY, strafeRightX);
        
        // Draw strafe right vector (blue)
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(strafeRightX * 30, strafeRightY * 30);
        ctx.strokeStyle = 'blue';
        ctx.lineWidth = 3;
        ctx.stroke();
        
        // If actively strafing, draw the movement vector in red
        if (strafingLeft || strafingRight) {
            const magnitude = 50; // Length of the strafe indicator
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(
                Math.cos(strafeAngle) * magnitude,
                Math.sin(strafeAngle) * magnitude
            );
            ctx.strokeStyle = 'red';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // Show which strafe direction is active
            ctx.fillStyle = 'rgba(255,0,0,0.5)';
            ctx.fillRect(-50, -65, 100, 24);
            ctx.fillStyle = 'white';
            ctx.textAlign = 'center';
            ctx.fillText(`STRAFING ${strafingLeft ? "LEFT" : "RIGHT"}`, 0, -50);
        }
        
        // Add status indicator showing the strafing mode
        ctx.fillStyle = 'rgba(0,0,0,0.7)';
        ctx.fillRect(-90, -80, 180, 24);
        ctx.fillStyle = isFacingDown ? '#ffaa00' : '#00ffaa';
        ctx.font = "14px Arial";
        ctx.textAlign = "center";
        ctx.fillText(`Strafe mode: ${isFacingDown ? "FLIPPED" : "NORMAL"}`, 0, -65);
        
        // Calculate positions for A/D labels with proper scaling
        const labelDistance = 45; // Distance from player for labels
        
        // Left label background
        ctx.fillStyle = 'rgba(0,0,0,0.7)';
        ctx.fillRect(
            -strafeRightX * labelDistance - 15,
            -strafeRightY * labelDistance - 10,
            30, 20
        );
        
        // Right label background
        ctx.fillRect(
            strafeRightX * labelDistance - 15,
            strafeRightY * labelDistance - 10,
            30, 20
        );
        
        // Draw strafe indicators with larger font
        const leftLabel = "A ←";
        const rightLabel = "→ D";
        ctx.font = "14px Arial";
        ctx.fillStyle = "white";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(leftLabel, -strafeRightX * labelDistance, -strafeRightY * labelDistance);
        ctx.fillText(rightLabel, strafeRightX * labelDistance, strafeRightY * labelDistance);
        
        // Draw angle indicator at the top with more details
        ctx.fillStyle = 'rgba(0,0,0,0.7)';
        ctx.fillRect(-55, -50, 110, 24);
        ctx.fillStyle = 'yellow';
        ctx.fillText(`Angle: ${Math.round(angleDeg)}°`, 0, -38);
        
        ctx.restore();
    }

    // Start the game
    init();
  </script>
</body>
</html>